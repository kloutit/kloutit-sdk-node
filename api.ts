/* tslint:disable */
/* eslint-disable */
/**
 * API Reference
 * The Kloutit API is organized around [REST](https://en.wikipedia.org/wiki/REST), it accepts and returns [JSON-encoded](https://www.json.org) bodies, returning standard [HTTP response codes](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes). You can interact with the API directly using your preferred HTTP/REST library.
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, BaseAPI, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Amount
 */
export interface Amount {
    /**
     * 
     * @type {number}
     * @memberof Amount
     */
    'value': number;
    /**
     * 
     * @type {Currencies}
     * @memberof Amount
     */
    'currency': Currencies;
}


/**
 * 
 * @export
 * @interface Case
 */
export interface Case {
    /**
     * 
     * @type {string}
     * @memberof Case
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Case
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Case
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Case
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Case
     */
    'isDeleted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Case
     */
    'deletedAt'?: string;
    /**
     * 
     * @type {CaseStatus}
     * @memberof Case
     */
    'status': CaseStatus;
    /**
     * The sales channel code related to the case.
     * @type {string}
     * @memberof Case
     */
    'salesChannelCode'?: string;
    /**
     * Filial identifier related to the case.
     * @type {string}
     * @memberof Case
     */
    'filialIdentifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof Case
     */
    'paymentProcessor'?: CasePaymentProcessorEnum;
    /**
     * Date when the customer made the purchase in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'purchaseDate': string;
    /**
     * Service that the customer bought.
     * @type {string}
     * @memberof Case
     */
    'service'?: string;
    /**
     * Product that the customer bought.
     * @type {string}
     * @memberof Case
     */
    'product'?: string;
    /**
     * Flag that indicates if the charge made is refundable regarding your company terms and conditions.
     * @type {boolean}
     * @memberof Case
     */
    'isChargeRefundable': boolean;
    /**
     * Customer name.
     * @type {string}
     * @memberof Case
     */
    'customerName'?: string;
    /**
     * Customer email
     * @type {string}
     * @memberof Case
     */
    'customerEmail'?: string;
    /**
     * Customer phone.
     * @type {string}
     * @memberof Case
     */
    'customerPhone'?: string;
    /**
     * Date when the service was provided or will be provided in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'serviceDate'?: string;
    /**
     * Flag that indicates if the service was provided or not.
     * @type {boolean}
     * @memberof Case
     */
    'serviceWasProvided'?: boolean;
    /**
     * Check in date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'checkinDate'?: string;
    /**
     * Check out date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'checkoutDate'?: string;
    /**
     * Hotel name.
     * @type {string}
     * @memberof Case
     */
    'hotelName'?: string;
    /**
     * Rate applied.
     * @type {string}
     * @memberof Case
     */
    'rate'?: string;
    /**
     * Rate applied in return trip.
     * @type {string}
     * @memberof Case
     */
    'inboundRate'?: string;
    /**
     * Flag that indicates if the client made the checkin or not.
     * @type {boolean}
     * @memberof Case
     */
    'checkinConfirmation'?: boolean;
    /**
     * Departure country.
     * @type {string}
     * @memberof Case
     */
    'departureCountry'?: string;
    /**
     * Destination country.
     * @type {string}
     * @memberof Case
     */
    'destinationCountry'?: string;
    /**
     * Departure date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'departureDate'?: string;
    /**
     * Arrival date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'arrivalDate'?: string;
    /**
     * Departure country of return trip.
     * @type {string}
     * @memberof Case
     */
    'inboundDepartureCountry'?: string;
    /**
     * Destination country of return trip.
     * @type {string}
     * @memberof Case
     */
    'inboundDestinationCountry'?: string;
    /**
     * Departure date of return trip in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'inboundDepartureDate'?: string;
    /**
     * Arrival date of return trip in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'inboundArrivalDate'?: string;
    /**
     * Departure airport.
     * @type {string}
     * @memberof Case
     */
    'departureAirport'?: string;
    /**
     * Arrival airport.
     * @type {string}
     * @memberof Case
     */
    'arrivalAirport'?: string;
    /**
     * Departure airport of return trip.
     * @type {string}
     * @memberof Case
     */
    'inboundDepartureAirport'?: string;
    /**
     * Arrival airport of return trip.
     * @type {string}
     * @memberof Case
     */
    'inboundArrivalAirport'?: string;
    /**
     * Departure city.
     * @type {string}
     * @memberof Case
     */
    'departureCity'?: string;
    /**
     * Arrival city.
     * @type {string}
     * @memberof Case
     */
    'arrivalCity'?: string;
    /**
     * Departure city of return trip.
     * @type {string}
     * @memberof Case
     */
    'inboundDepartureCity'?: string;
    /**
     * Arrival city of return trip.
     * @type {string}
     * @memberof Case
     */
    'inboundArrivalCity'?: string;
    /**
     * Shipping city.
     * @type {string}
     * @memberof Case
     */
    'shippingCity'?: string;
    /**
     * Shipping province.
     * @type {string}
     * @memberof Case
     */
    'shippingProvince'?: string;
    /**
     * Shipping postal code.
     * @type {string}
     * @memberof Case
     */
    'shippingPostalCode'?: string;
    /**
     * Shipping date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'shippingDate'?: string;
    /**
     * Delivery date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'deliveryDate'?: string;
    /**
     * Delivery company.
     * @type {string}
     * @memberof Case
     */
    'deliveryCompany'?: string;
    /**
     * Flag that indicates if the customer received the product.
     * @type {boolean}
     * @memberof Case
     */
    'deliveryConfirmation'?: boolean;
    /**
     * Start date in UTC and ISO 8601 format of the commitment that the customer has with the company.
     * @type {string}
     * @memberof Case
     */
    'commitmentStartDate'?: string;
    /**
     * End date in UTC and ISO 8601 format of the commitment that the customer has with the company.
     * @type {string}
     * @memberof Case
     */
    'commitmentEndDate'?: string;
    /**
     * Flag that indicates if the subscription is cancelled or active.
     * @type {boolean}
     * @memberof Case
     */
    'isCancelled'?: boolean;
    /**
     * Product description.
     * @type {string}
     * @memberof Case
     */
    'productDescription'?: string;
    /**
     * Chargeback expedient number.
     * @type {string}
     * @memberof Case
     */
    'expedientNumber': string;
    /**
     * Chargeback notification date, when the merchant receives the chargeback notification, in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'notificationDate': string;
    /**
     * 
     * @type {CreateCaseParamsDisputeAmount}
     * @memberof Case
     */
    'disputeAmount': CreateCaseParamsDisputeAmount;
    /**
     * 
     * @type {ChargebackReason}
     * @memberof Case
     */
    'chargebackReason': ChargebackReason;
    /**
     * Deadline date to resolve this chargeback in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'deadline'?: string;
    /**
     * Order number related to the case.
     * @type {string}
     * @memberof Case
     */
    'orderNumber'?: string;
    /**
     * Ticket number related to the case.
     * @type {string}
     * @memberof Case
     */
    'ticketNumber'?: string;
    /**
     * Date when the customer contacted to the merchant in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'contactDate'?: string;
    /**
     * Array of all the emails that the customer has sent regarding this dispute. The structure of each item contains: **sender**: *customer* or *company*, **date**, **content**: string containing the message
     * @type {Array<CommunicationItem>}
     * @memberof Case
     */
    'communications'?: Array<CommunicationItem>;
    /**
     * Additional info related to the chargeback.
     * @type {string}
     * @memberof Case
     */
    'additionalInfo'?: string;
    /**
     * Last 4 digits of the customer\'s credit card number.
     * @type {string}
     * @memberof Case
     */
    'last4Digits'?: string;
    /**
     * Transaction id.
     * @type {string}
     * @memberof Case
     */
    'transactionId'?: string;
    /**
     * Transaction date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'transactionDate': string;
    /**
     * Purchase amount.
     * @type {Amount}
     * @memberof Case
     */
    'purchaseAmount': Amount;
    /**
     * Customer bank name.
     * @type {string}
     * @memberof Case
     */
    'bankName'?: string;
    /**
     * Card brand that the customer used to make the payment.
     * @type {string}
     * @memberof Case
     */
    'cardBrand'?: string;
    /**
     * Flag that indicates if the purchase has been made with 3DS.
     * @type {boolean}
     * @memberof Case
     */
    'is3DSPurchase'?: boolean;
    /**
     * Organization sector of the case.
     * @type {string}
     * @memberof Case
     */
    'sector'?: CaseSectorEnum;
    /**
     * Date when the customer contacted to the seller in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'sellerContactDate'?: string;
    /**
     * Seller additional infromation.
     * @type {string}
     * @memberof Case
     */
    'sellerAdditionalInfo'?: string;
    /**
     * Seller name.
     * @type {string}
     * @memberof Case
     */
    'sellerName'?: string;
    /**
     * Seller phone number.
     * @type {string}
     * @memberof Case
     */
    'sellerPhone'?: string;
    /**
     * Seller email.
     * @type {string}
     * @memberof Case
     */
    'sellerEmail'?: string;
}

export const CasePaymentProcessorEnum = {
    STRIPE: 'STRIPE',
    CHECKOUT_COM: 'CHECKOUT_COM',
    WORLDLINE: 'WORLDLINE',
    REDSYS: 'REDSYS',
    PAYPAL: 'PAYPAL',
    MANGOPAY: 'MANGOPAY',
    ADYEN: 'ADYEN',
    SHOPIFY: 'SHOPIFY',
    KLARNA: 'KLARNA',
    DLOCAL: 'DLOCAL'
} as const;

export type CasePaymentProcessorEnum = typeof CasePaymentProcessorEnum[keyof typeof CasePaymentProcessorEnum];
export const CaseSectorEnum = {
    DIGITAL_PRODUCT: 'DIGITAL_PRODUCT',
    EDUCATION: 'EDUCATION',
    FASHION: 'FASHION',
    FOOD: 'FOOD',
    GAMING: 'GAMING',
    HEALTH_BEAUTY: 'HEALTH_BEAUTY',
    HOME: 'HOME',
    LEISURE: 'LEISURE',
    MARKETPLACE: 'MARKETPLACE',
    PHONE: 'PHONE',
    SOFTWARE: 'SOFTWARE',
    SPORT: 'SPORT',
    SUBSCRIPTION: 'SUBSCRIPTION',
    SUPPLY: 'SUPPLY',
    TECHNOLOGY: 'TECHNOLOGY',
    TRANSPORT: 'TRANSPORT',
    TRAVEL_AIRLINE: 'TRAVEL_AIRLINE',
    TRAVEL_HOTEL: 'TRAVEL_HOTEL'
} as const;

export type CaseSectorEnum = typeof CaseSectorEnum[keyof typeof CaseSectorEnum];

/**
 * Sector of the case. It must be one of the sectors of the organization, for instance: EDUCATION, SOFTWARE, TRAVEL_HOTEL,...
 * @export
 * @enum {string}
 */

export const CaseSector = {
    DIGITAL_PRODUCT: 'DIGITAL_PRODUCT',
    EDUCATION: 'EDUCATION',
    FASHION: 'FASHION',
    FOOD: 'FOOD',
    GAMING: 'GAMING',
    HEALTH_BEAUTY: 'HEALTH_BEAUTY',
    HOME: 'HOME',
    LEISURE: 'LEISURE',
    MARKETPLACE: 'MARKETPLACE',
    PHONE: 'PHONE',
    SOFTWARE: 'SOFTWARE',
    SPORT: 'SPORT',
    SUBSCRIPTION: 'SUBSCRIPTION',
    SUPPLY: 'SUPPLY',
    TECHNOLOGY: 'TECHNOLOGY',
    TRANSPORT: 'TRANSPORT',
    TRAVEL_AIRLINE: 'TRAVEL_AIRLINE',
    TRAVEL_HOTEL: 'TRAVEL_HOTEL'
} as const;

export type CaseSector = typeof CaseSector[keyof typeof CaseSector];


/**
 * Current status of the case.
 * @export
 * @enum {string}
 */

export const CaseStatus = {
    PENDING: 'PENDING',
    GENERATING: 'GENERATING',
    GENERATED: 'GENERATED',
    ALLEGING: 'ALLEGING',
    ALLEGED: 'ALLEGED',
    WON: 'WON',
    LOST: 'LOST',
    ACCEPTED: 'ACCEPTED',
    EXPIRED: 'EXPIRED'
} as const;

export type CaseStatus = typeof CaseStatus[keyof typeof CaseStatus];


/**
 * Reason why the customer is requesting the chargeback.
 * @export
 * @enum {string}
 */

export const ChargebackReason = {
    FRAUD: 'FRAUD',
    PRODUCT_SERVICE_NOT_RECEIVED: 'PRODUCT_SERVICE_NOT_RECEIVED',
    DEFECTIVE_PRODUCT_SERVICE: 'DEFECTIVE_PRODUCT_SERVICE',
    PRODUCT_SERVICE_NOT_AS_DESCRIBED: 'PRODUCT_SERVICE_NOT_AS_DESCRIBED',
    INCORRECT_DUPLICATED_CHARGES: 'INCORRECT_DUPLICATED_CHARGES',
    PRODUCT_SERVICE_CANCELLED: 'PRODUCT_SERVICE_CANCELLED',
    REFUND_NOT_RECEIVED: 'REFUND_NOT_RECEIVED',
    RECURRENT_OPERATION_CANCELLED: 'RECURRENT_OPERATION_CANCELLED'
} as const;

export type ChargebackReason = typeof ChargebackReason[keyof typeof ChargebackReason];


/**
 * 
 * @export
 * @interface ClientWebhookEventDto
 */
export interface ClientWebhookEventDto {
    /**
     * The type of the webhook event
     * @type {string}
     * @memberof ClientWebhookEventDto
     */
    'eventType': string;
    /**
     * The expedient number of the case that the webhook event is related to
     * @type {string}
     * @memberof ClientWebhookEventDto
     */
    'expedientNumber': string;
    /**
     * The details of the case that the webhook event is related to
     * @type {object}
     * @memberof ClientWebhookEventDto
     */
    'details': object;
}
/**
 * 
 * @export
 * @interface CommunicationItem
 */
export interface CommunicationItem {
    /**
     * 
     * @type {string}
     * @memberof CommunicationItem
     */
    'sender': string;
    /**
     * 
     * @type {string}
     * @memberof CommunicationItem
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof CommunicationItem
     */
    'date': string;
}
/**
 * 
 * @export
 * @interface CreateCaseParams
 */
export interface CreateCaseParams {
    /**
     * Sales channel code related to the case. This should be the sales channel code that is configured for your organization in Kloutit. If you do not have sales channels in your organization, leave this field empty.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'salesChannelCode'?: string;
    /**
     * Filial identifier related to the case. This should be the NIF, VAT or other unique identifier that is configured for your organization in Kloutit. If you do not have filials in your organization, leave this field empty.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'filialIdentifier'?: string;
    /**
     * Date when the customer made the purchase in UTC and ISO 8601 format.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'purchaseDate'?: string;
    /**
     * Service that the customer bought.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'service'?: string;
    /**
     * Product that the customer bought.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'product'?: string;
    /**
     * Flag that indicates if the charge made is refundable regarding your company terms and conditions.
     * @type {boolean}
     * @memberof CreateCaseParams
     */
    'isChargeRefundable'?: boolean;
    /**
     * Customer name.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'customerName'?: string;
    /**
     * Customer email
     * @type {string}
     * @memberof CreateCaseParams
     */
    'customerEmail'?: string;
    /**
     * Customer phone.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'customerPhone'?: string;
    /**
     * Date when the service was provided or will be provided in UTC and ISO 8601 format.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'serviceDate'?: string;
    /**
     * Flag that indicates if the service was provided or not.
     * @type {boolean}
     * @memberof CreateCaseParams
     */
    'serviceWasProvided'?: boolean;
    /**
     * Check in date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'checkinDate'?: string;
    /**
     * Check out date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'checkoutDate'?: string;
    /**
     * Hotel name.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'hotelName'?: string;
    /**
     * Rate applied.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'rate'?: string;
    /**
     * Rate applied in return trip.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'inboundRate'?: string;
    /**
     * Flag that indicates if the client made the checkin or not.
     * @type {boolean}
     * @memberof CreateCaseParams
     */
    'checkinConfirmation'?: boolean;
    /**
     * Departure country.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'departureCountry'?: string;
    /**
     * Destination country.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'destinationCountry'?: string;
    /**
     * Departure date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'departureDate'?: string;
    /**
     * Arrival date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'arrivalDate'?: string;
    /**
     * Departure country of return trip.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'inboundDepartureCountry'?: string;
    /**
     * Destination country of return trip.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'inboundDestinationCountry'?: string;
    /**
     * Departure date of return trip in UTC and ISO 8601 format.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'inboundDepartureDate'?: string;
    /**
     * Arrival date of return trip in UTC and ISO 8601 format.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'inboundArrivalDate'?: string;
    /**
     * Departure airport.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'departureAirport'?: string;
    /**
     * Arrival airport.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'arrivalAirport'?: string;
    /**
     * Departure airport of return trip.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'inboundDepartureAirport'?: string;
    /**
     * Arrival airport of return trip.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'inboundArrivalAirport'?: string;
    /**
     * Departure city.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'departureCity'?: string;
    /**
     * Arrival city.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'arrivalCity'?: string;
    /**
     * Departure city of return trip.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'inboundDepartureCity'?: string;
    /**
     * Arrival city of return trip.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'inboundArrivalCity'?: string;
    /**
     * Shipping city.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'shippingCity'?: string;
    /**
     * Shipping province.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'shippingProvince'?: string;
    /**
     * Shipping postal code.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'shippingPostalCode'?: string;
    /**
     * Shipping date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'shippingDate'?: string;
    /**
     * Delivery date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'deliveryDate'?: string;
    /**
     * Delivery company.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'deliveryCompany'?: string;
    /**
     * Flag that indicates if the customer received the product.
     * @type {boolean}
     * @memberof CreateCaseParams
     */
    'deliveryConfirmation'?: boolean;
    /**
     * Start date in UTC and ISO 8601 format of the commitment that the customer has with the company.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'commitmentStartDate'?: string;
    /**
     * End date in UTC and ISO 8601 format of the commitment that the customer has with the company.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'commitmentEndDate'?: string;
    /**
     * Flag that indicates if the subscription is cancelled or active.
     * @type {boolean}
     * @memberof CreateCaseParams
     */
    'isCancelled'?: boolean;
    /**
     * Product description.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'productDescription'?: string;
    /**
     * Chargeback expedient number.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'expedientNumber'?: string;
    /**
     * Chargeback notification date, when the merchant receives the chargeback notification, in UTC and ISO 8601 format.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'notificationDate'?: string;
    /**
     * 
     * @type {CreateCaseParamsDisputeAmount}
     * @memberof CreateCaseParams
     */
    'disputeAmount'?: CreateCaseParamsDisputeAmount;
    /**
     * 
     * @type {ChargebackReason}
     * @memberof CreateCaseParams
     */
    'chargebackReason'?: ChargebackReason;
    /**
     * Deadline date to resolve this chargeback in UTC and ISO 8601 format.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'deadline'?: string;
    /**
     * Order number related to the case.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'orderNumber'?: string;
    /**
     * Ticket number related to the case.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'ticketNumber'?: string;
    /**
     * Date when the customer contacted to the merchant in UTC and ISO 8601 format.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'contactDate'?: string;
    /**
     * Array of all the emails that the customer has sent regarding this dispute. The structure of each item contains: **sender**: *customer* or *company*, **date**, **content**: string containing the message
     * @type {Array<CommunicationItem>}
     * @memberof CreateCaseParams
     */
    'communications'?: Array<CommunicationItem>;
    /**
     * Additional info related to the chargeback.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'additionalInfo'?: string;
    /**
     * Last 4 digits of the customer\'s credit card number.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'last4Digits'?: string;
    /**
     * Transaction id.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'transactionId'?: string;
    /**
     * Transaction date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'transactionDate'?: string;
    /**
     * Purchase amount.
     * @type {Amount}
     * @memberof CreateCaseParams
     */
    'purchaseAmount'?: Amount;
    /**
     * Customer bank name.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'bankName'?: string;
    /**
     * Card brand that the customer used to make the payment.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'cardBrand'?: string;
    /**
     * Flag that indicates if the purchase has been made with 3DS.
     * @type {boolean}
     * @memberof CreateCaseParams
     */
    'is3DSPurchase'?: boolean;
    /**
     * 
     * @type {CaseSector}
     * @memberof CreateCaseParams
     */
    'sector'?: CaseSector;
    /**
     * Date when the customer contacted to the seller in UTC and ISO 8601 format.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'sellerContactDate'?: string;
    /**
     * Seller additional infromation.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'sellerAdditionalInfo'?: string;
    /**
     * Seller name.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'sellerName'?: string;
    /**
     * Seller phone number.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'sellerPhone'?: string;
    /**
     * Seller email.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'sellerEmail'?: string;
    /**
     * Sales channel Terms and Conditions URL. If Sales Channel Code is provided and not exists in organization, this field is required and should be the URL of the terms and conditions of the sales channel.
     * @type {string}
     * @memberof CreateCaseParams
     */
    'salesChannelTermsUrl'?: string;
}


/**
 * Amount that the customer claims.
 * @export
 * @interface CreateCaseParamsDisputeAmount
 */
export interface CreateCaseParamsDisputeAmount {
    /**
     * 
     * @type {number}
     * @memberof CreateCaseParamsDisputeAmount
     */
    'value': number;
    /**
     * 
     * @type {Currencies}
     * @memberof CreateCaseParamsDisputeAmount
     */
    'currency': Currencies;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const Currencies = {
    EUR: 'EUR',
    GBP: 'GBP',
    CHF: 'CHF',
    NOK: 'NOK',
    DKK: 'DKK',
    SEK: 'SEK',
    BGN: 'BGN',
    HRK: 'HRK',
    CZK: 'CZK',
    HUF: 'HUF',
    PLN: 'PLN',
    RON: 'RON',
    ISK: 'ISK',
    RUB: 'RUB',
    MKD: 'MKD',
    RSD: 'RSD',
    ARS: 'ARS',
    BOB: 'BOB',
    BRL: 'BRL',
    CLP: 'CLP',
    COP: 'COP',
    CRC: 'CRC',
    CUP: 'CUP',
    DOP: 'DOP',
    GTQ: 'GTQ',
    HNL: 'HNL',
    MXN: 'MXN',
    NIO: 'NIO',
    PAB: 'PAB',
    PYG: 'PYG',
    PEN: 'PEN',
    SRD: 'SRD',
    UYU: 'UYU',
    VES: 'VES',
    USD: 'USD',
    CAD: 'CAD',
    CNY: 'CNY',
    JPY: 'JPY',
    INR: 'INR',
    KRW: 'KRW',
    IDR: 'IDR',
    MYR: 'MYR',
    PHP: 'PHP',
    SGD: 'SGD',
    THB: 'THB',
    VND: 'VND',
    HKD: 'HKD',
    TWD: 'TWD',
    TRY: 'TRY',
    AUD: 'AUD',
    NZD: 'NZD',
    FJD: 'FJD',
    PGK: 'PGK',
    WST: 'WST',
    VUV: 'VUV'
} as const;

export type Currencies = typeof Currencies[keyof typeof Currencies];


/**
 * 
 * @export
 * @interface FileItem
 */
export interface FileItem {
    /**
     * File name
     * @type {string}
     * @memberof FileItem
     */
    'name': string;
    /**
     * Uploaded file date
     * @type {string}
     * @memberof FileItem
     */
    'uploadedAt': string;
    /**
     * File size in bytes
     * @type {number}
     * @memberof FileItem
     */
    'size': number;
    /**
     * File mimetype
     * @type {string}
     * @memberof FileItem
     */
    'mimetype': string;
    /**
     * File category.
     * @type {string}
     * @memberof FileItem
     */
    'category': FileItemCategoryEnum;
}

export const FileItemCategoryEnum = {
    RECEIPT: 'RECEIPT',
    CUSTOMER_COMMUNICATION: 'CUSTOMER_COMMUNICATION',
    CUSTOMER_SIGNATURE: 'CUSTOMER_SIGNATURE',
    PAYMENT_AUTHORIZATION: 'PAYMENT_AUTHORIZATION',
    CUSTOMER_VISUAL_EVIDENCE: 'CUSTOMER_VISUAL_EVIDENCE',
    CUSTOMER_UNCATEGORIZED_FILE: 'CUSTOMER_UNCATEGORIZED_FILE',
    CANCELLATION_POLICY: 'CANCELLATION_POLICY',
    REFUND_POLICY: 'REFUND_POLICY',
    REFUND_EVIDENCE: 'REFUND_EVIDENCE',
    TERMS_AND_CONDITIONS: 'TERMS_AND_CONDITIONS',
    DUPLICATE_CHARGE_DOCUMENTATION: 'DUPLICATE_CHARGE_DOCUMENTATION',
    SERVICE_EVIDENCE: 'SERVICE_EVIDENCE',
    SHIPPING_EVIDENCE: 'SHIPPING_EVIDENCE',
    COMPANY_VISUAL_EVIDENCE: 'COMPANY_VISUAL_EVIDENCE',
    COMPANY_UNCATEGORIZED_FILE: 'COMPANY_UNCATEGORIZED_FILE'
} as const;

export type FileItemCategoryEnum = typeof FileItemCategoryEnum[keyof typeof FileItemCategoryEnum];

/**
 * 
 * @export
 * @interface MissingFieldDto
 */
export interface MissingFieldDto {
    /**
     * 
     * @type {string}
     * @memberof MissingFieldDto
     */
    'field': string;
    /**
     * 
     * @type {string}
     * @memberof MissingFieldDto
     */
    'type': string;
    /**
     * 
     * @type {boolean}
     * @memberof MissingFieldDto
     */
    'required': boolean;
}
/**
 * 
 * @export
 * @interface MissingFieldsDto
 */
export interface MissingFieldsDto {
    /**
     * Array of all the Case entity fields that are found missing for the evaluated case
     * @type {Array<MissingFieldDto>}
     * @memberof MissingFieldsDto
     */
    'missingFields': Array<MissingFieldDto>;
}
/**
 * 
 * @export
 * @interface UpdateCaseParams
 */
export interface UpdateCaseParams {
    /**
     * Sales channel code related to the case. This should be the sales channel code that is configured for your organization in Kloutit. If you do not have sales channels in your organization, leave this field empty.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'salesChannelCode'?: string;
    /**
     * Filial identifier related to the case. This should be the NIF, VAT or other unique identifier that is configured for your organization in Kloutit. If you do not have filials in your organization, leave this field empty.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'filialIdentifier'?: string;
    /**
     * Date when the customer made the purchase in UTC and ISO 8601 format.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'purchaseDate'?: string;
    /**
     * Service that the customer bought.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'service'?: string;
    /**
     * Product that the customer bought.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'product'?: string;
    /**
     * Flag that indicates if the charge made is refundable regarding your company terms and conditions.
     * @type {boolean}
     * @memberof UpdateCaseParams
     */
    'isChargeRefundable'?: boolean;
    /**
     * Customer name.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'customerName'?: string;
    /**
     * Customer email
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'customerEmail'?: string;
    /**
     * Customer phone.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'customerPhone'?: string;
    /**
     * Date when the service was provided or will be provided in UTC and ISO 8601 format.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'serviceDate'?: string;
    /**
     * Flag that indicates if the service was provided or not.
     * @type {boolean}
     * @memberof UpdateCaseParams
     */
    'serviceWasProvided'?: boolean;
    /**
     * Check in date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'checkinDate'?: string;
    /**
     * Check out date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'checkoutDate'?: string;
    /**
     * Hotel name.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'hotelName'?: string;
    /**
     * Rate applied.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'rate'?: string;
    /**
     * Rate applied in return trip.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'inboundRate'?: string;
    /**
     * Flag that indicates if the client made the checkin or not.
     * @type {boolean}
     * @memberof UpdateCaseParams
     */
    'checkinConfirmation'?: boolean;
    /**
     * Departure country.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'departureCountry'?: string;
    /**
     * Destination country.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'destinationCountry'?: string;
    /**
     * Departure date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'departureDate'?: string;
    /**
     * Arrival date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'arrivalDate'?: string;
    /**
     * Departure country of return trip.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'inboundDepartureCountry'?: string;
    /**
     * Destination country of return trip.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'inboundDestinationCountry'?: string;
    /**
     * Departure date of return trip in UTC and ISO 8601 format.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'inboundDepartureDate'?: string;
    /**
     * Arrival date of return trip in UTC and ISO 8601 format.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'inboundArrivalDate'?: string;
    /**
     * Departure airport.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'departureAirport'?: string;
    /**
     * Arrival airport.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'arrivalAirport'?: string;
    /**
     * Departure airport of return trip.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'inboundDepartureAirport'?: string;
    /**
     * Arrival airport of return trip.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'inboundArrivalAirport'?: string;
    /**
     * Departure city.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'departureCity'?: string;
    /**
     * Arrival city.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'arrivalCity'?: string;
    /**
     * Departure city of return trip.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'inboundDepartureCity'?: string;
    /**
     * Arrival city of return trip.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'inboundArrivalCity'?: string;
    /**
     * Shipping city.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'shippingCity'?: string;
    /**
     * Shipping province.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'shippingProvince'?: string;
    /**
     * Shipping postal code.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'shippingPostalCode'?: string;
    /**
     * Shipping date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'shippingDate'?: string;
    /**
     * Delivery date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'deliveryDate'?: string;
    /**
     * Delivery company.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'deliveryCompany'?: string;
    /**
     * Flag that indicates if the customer received the product.
     * @type {boolean}
     * @memberof UpdateCaseParams
     */
    'deliveryConfirmation'?: boolean;
    /**
     * Start date in UTC and ISO 8601 format of the commitment that the customer has with the company.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'commitmentStartDate'?: string;
    /**
     * End date in UTC and ISO 8601 format of the commitment that the customer has with the company.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'commitmentEndDate'?: string;
    /**
     * Flag that indicates if the subscription is cancelled or active.
     * @type {boolean}
     * @memberof UpdateCaseParams
     */
    'isCancelled'?: boolean;
    /**
     * Product description.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'productDescription'?: string;
    /**
     * Order number related to the case.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'orderNumber'?: string;
    /**
     * Ticket number related to the case.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'ticketNumber'?: string;
    /**
     * Date when the customer contacted to the merchant in UTC and ISO 8601 format.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'contactDate'?: string;
    /**
     * Array of all the emails that the customer has sent regarding this dispute. The structure of each item contains: **sender**: *customer* or *company*, **date**, **content**: string containing the message
     * @type {Array<CommunicationItem>}
     * @memberof UpdateCaseParams
     */
    'communications'?: Array<CommunicationItem>;
    /**
     * Additional info related to the chargeback.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'additionalInfo'?: string;
    /**
     * Last 4 digits of the customer\'s credit card number.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'last4Digits'?: string;
    /**
     * Transaction date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'transactionDate'?: string;
    /**
     * Purchase amount.
     * @type {Amount}
     * @memberof UpdateCaseParams
     */
    'purchaseAmount'?: Amount;
    /**
     * Customer bank name.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'bankName'?: string;
    /**
     * Card brand that the customer used to make the payment.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'cardBrand'?: string;
    /**
     * Flag that indicates if the purchase has been made with 3DS.
     * @type {boolean}
     * @memberof UpdateCaseParams
     */
    'is3DSPurchase'?: boolean;
    /**
     * 
     * @type {CaseSector}
     * @memberof UpdateCaseParams
     */
    'sector'?: CaseSector;
    /**
     * Date when the customer contacted to the seller in UTC and ISO 8601 format.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'sellerContactDate'?: string;
    /**
     * Seller additional infromation.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'sellerAdditionalInfo'?: string;
    /**
     * Seller name.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'sellerName'?: string;
    /**
     * Seller phone number.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'sellerPhone'?: string;
    /**
     * Seller email.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'sellerEmail'?: string;
    /**
     * Sales channel Terms and Conditions URL. If Sales Channel Code is provided and not exists in organization, this field is required and should be the URL of the terms and conditions of the sales channel.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'salesChannelTermsUrl'?: string;
}



/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthControllerHealth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthControllerHealth(options);
            const localVarOperationServerIndex = 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.healthControllerHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerHealth(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.healthControllerHealth(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @summary Health check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public healthControllerHealth(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthControllerHealth(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * KloutitCaseApi - axios parameter creator
 * @export
 */
export const KloutitCaseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Validates that the case has been updated with all the needed information. It indicates in the response if there are still some fields that could be informed to Kloutit before generating the dispute. It also informs the type and the required nature of each field.
         * @summary Check case information
         * @param {string} expedientNumber Case expedient number. This value must exist in Kloutit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkCase: async (expedientNumber: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'expedientNumber' is not null or undefined
            assertParamExists('checkCase', 'expedientNumber', expedientNumber)
            const localVarPath = `/case/{expedientNumber}/check-case`
                .replace(`{${"expedientNumber"}}`, encodeURIComponent(String(expedientNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Case SDK call to create a new chargeback case from your system into Kloutit. API Key authentication is required in the x-api-key header.
         * @summary Create a new case into Kloutit.
         * @param {CreateCaseParams} createCaseParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCase: async (createCaseParams: CreateCaseParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCaseParams' is not null or undefined
            assertParamExists('createCase', 'createCaseParams', createCaseParams)
            const localVarPath = `/case`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCaseParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Downloads the case defense with the given format
         * @summary Download the case defense
         * @param {string} expedientNumber Case expedient number
         * @param {DownloadCaseDefenseFormatEnum} format Format parameter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCaseDefense: async (expedientNumber: string, format: DownloadCaseDefenseFormatEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'expedientNumber' is not null or undefined
            assertParamExists('downloadCaseDefense', 'expedientNumber', expedientNumber)
            // verify required parameter 'format' is not null or undefined
            assertParamExists('downloadCaseDefense', 'format', format)
            const localVarPath = `/case/download-defense/{format}/{expedientNumber}`
                .replace(`{${"expedientNumber"}}`, encodeURIComponent(String(expedientNumber)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits that the case has been updated with all the needed information. If you have configured automated dispute generation in Kloutit, this endpoint will indicate that the case is ready and will trigger the defense generation automatically.
         * @summary Submit completed case
         * @param {string} expedientNumber Case expedient number. This value must exist in Kloutit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitCompletedCase: async (expedientNumber: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'expedientNumber' is not null or undefined
            assertParamExists('submitCompletedCase', 'expedientNumber', expedientNumber)
            const localVarPath = `/case/{expedientNumber}/submit-completed-case`
                .replace(`{${"expedientNumber"}}`, encodeURIComponent(String(expedientNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates data to enrich an existing case in order to generate a more complete defense and increase the chances of winning.
         * @summary Update case
         * @param {string} expedientNumber Case expedient number. This value must exist in Kloutit.
         * @param {UpdateCaseParams} updateCaseParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCase: async (expedientNumber: string, updateCaseParams: UpdateCaseParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'expedientNumber' is not null or undefined
            assertParamExists('updateCase', 'expedientNumber', expedientNumber)
            // verify required parameter 'updateCaseParams' is not null or undefined
            assertParamExists('updateCase', 'updateCaseParams', updateCaseParams)
            const localVarPath = `/case/{expedientNumber}/update-case`
                .replace(`{${"expedientNumber"}}`, encodeURIComponent(String(expedientNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCaseParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads a file into an existing case. You need to send a request of type ``multipart/form-data``. Allowed formats are ``PDF``, ``JPG``, ``JPEG``, ``PNG``. Max. file size is ``10Mb``
         * @summary Upload file
         * @param {string} expedientNumber 
         * @param {File} file A file to upload. Make sure that the specifications follow RFC 2388, which defines file transfers for the multipart/form-data protocol. Allowed formats are &#x60;&#x60;PDF&#x60;&#x60;, &#x60;&#x60;JPG&#x60;&#x60;, &#x60;&#x60;JPEG&#x60;&#x60;, &#x60;&#x60;PNG&#x60;&#x60;. Max. file size is &#x60;&#x60;10Mb&#x60;&#x60;. Ensure that the file upload adheres to [RFC 2388](https://www.ietf.org/rfc/rfc2388.txt), which defines file transfers for the multipart/form-data protocol.
         * @param {UploadFileCategoryEnum} category Category of the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (expedientNumber: string, file: File, category: UploadFileCategoryEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'expedientNumber' is not null or undefined
            assertParamExists('uploadFile', 'expedientNumber', expedientNumber)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadFile', 'file', file)
            // verify required parameter 'category' is not null or undefined
            assertParamExists('uploadFile', 'category', category)
            const localVarPath = `/case/{expedientNumber}/upload-file`
                .replace(`{${"expedientNumber"}}`, encodeURIComponent(String(expedientNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (category !== undefined) { 
                localVarFormParams.append('category', category as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads a product photo into an existing case. Only available for cases with sector MARKETPLACE. You need to send a request of type ``multipart/form-data``. This file can be attached only for marketplace company. Allowed formats are ``JPG``, ``JPEG``, ``PNG``. Max. file size is ``10Mb``
         * @summary Upload product photo
         * @param {string} expedientNumber 
         * @param {File} file A file to upload. Make sure that the specifications follow RFC 2388, which defines file transfers for the multipart/form-data protocol. Allowed formats are &#x60;&#x60;JPG&#x60;&#x60;, &#x60;&#x60;JPEG&#x60;&#x60;, &#x60;&#x60;PNG&#x60;&#x60;. Max. file size is &#x60;&#x60;10Mb&#x60;&#x60;. Ensure that the file upload adheres to [RFC 2388](https://www.ietf.org/rfc/rfc2388.txt), which defines file transfers for the multipart/form-data protocol.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProductPhoto: async (expedientNumber: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'expedientNumber' is not null or undefined
            assertParamExists('uploadProductPhoto', 'expedientNumber', expedientNumber)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadProductPhoto', 'file', file)
            const localVarPath = `/case/{expedientNumber}/upload-product-photo`
                .replace(`{${"expedientNumber"}}`, encodeURIComponent(String(expedientNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies if the webhook event received has been sent by Kloutit
         * @summary Verify webhook event
         * @param {ClientWebhookEventDto} clientWebhookEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEvent: async (clientWebhookEventDto: ClientWebhookEventDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientWebhookEventDto' is not null or undefined
            assertParamExists('verifyEvent', 'clientWebhookEventDto', clientWebhookEventDto)
            const localVarPath = `/case/verify-event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientWebhookEventDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KloutitCaseApi - functional programming interface
 * @export
 */
export const KloutitCaseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KloutitCaseApiAxiosParamCreator(configuration)
    return {
        /**
         * Validates that the case has been updated with all the needed information. It indicates in the response if there are still some fields that could be informed to Kloutit before generating the dispute. It also informs the type and the required nature of each field.
         * @summary Check case information
         * @param {string} expedientNumber Case expedient number. This value must exist in Kloutit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkCase(expedientNumber: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkCase(expedientNumber, options);
            const localVarOperationServerIndex = 0;
            const localVarOperationServerBasePath = operationServerMap['KloutitCaseApi.checkCase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Case SDK call to create a new chargeback case from your system into Kloutit. API Key authentication is required in the x-api-key header.
         * @summary Create a new case into Kloutit.
         * @param {CreateCaseParams} createCaseParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCase(createCaseParams: CreateCaseParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Case>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCase(createCaseParams, options);
            const localVarOperationServerIndex = 0;
            const localVarOperationServerBasePath = operationServerMap['KloutitCaseApi.createCase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Downloads the case defense with the given format
         * @summary Download the case defense
         * @param {string} expedientNumber Case expedient number
         * @param {DownloadCaseDefenseFormatEnum} format Format parameter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadCaseDefense(expedientNumber: string, format: DownloadCaseDefenseFormatEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadCaseDefense(expedientNumber, format, options);
            const localVarOperationServerIndex = 0;
            const localVarOperationServerBasePath = operationServerMap['KloutitCaseApi.downloadCaseDefense']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submits that the case has been updated with all the needed information. If you have configured automated dispute generation in Kloutit, this endpoint will indicate that the case is ready and will trigger the defense generation automatically.
         * @summary Submit completed case
         * @param {string} expedientNumber Case expedient number. This value must exist in Kloutit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitCompletedCase(expedientNumber: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitCompletedCase(expedientNumber, options);
            const localVarOperationServerIndex = 0;
            const localVarOperationServerBasePath = operationServerMap['KloutitCaseApi.submitCompletedCase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates data to enrich an existing case in order to generate a more complete defense and increase the chances of winning.
         * @summary Update case
         * @param {string} expedientNumber Case expedient number. This value must exist in Kloutit.
         * @param {UpdateCaseParams} updateCaseParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCase(expedientNumber: string, updateCaseParams: UpdateCaseParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Case>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCase(expedientNumber, updateCaseParams, options);
            const localVarOperationServerIndex = 0;
            const localVarOperationServerBasePath = operationServerMap['KloutitCaseApi.updateCase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uploads a file into an existing case. You need to send a request of type ``multipart/form-data``. Allowed formats are ``PDF``, ``JPG``, ``JPEG``, ``PNG``. Max. file size is ``10Mb``
         * @summary Upload file
         * @param {string} expedientNumber 
         * @param {File} file A file to upload. Make sure that the specifications follow RFC 2388, which defines file transfers for the multipart/form-data protocol. Allowed formats are &#x60;&#x60;PDF&#x60;&#x60;, &#x60;&#x60;JPG&#x60;&#x60;, &#x60;&#x60;JPEG&#x60;&#x60;, &#x60;&#x60;PNG&#x60;&#x60;. Max. file size is &#x60;&#x60;10Mb&#x60;&#x60;. Ensure that the file upload adheres to [RFC 2388](https://www.ietf.org/rfc/rfc2388.txt), which defines file transfers for the multipart/form-data protocol.
         * @param {UploadFileCategoryEnum} category Category of the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(expedientNumber: string, file: File, category: UploadFileCategoryEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(expedientNumber, file, category, options);
            const localVarOperationServerIndex = 0;
            const localVarOperationServerBasePath = operationServerMap['KloutitCaseApi.uploadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uploads a product photo into an existing case. Only available for cases with sector MARKETPLACE. You need to send a request of type ``multipart/form-data``. This file can be attached only for marketplace company. Allowed formats are ``JPG``, ``JPEG``, ``PNG``. Max. file size is ``10Mb``
         * @summary Upload product photo
         * @param {string} expedientNumber 
         * @param {File} file A file to upload. Make sure that the specifications follow RFC 2388, which defines file transfers for the multipart/form-data protocol. Allowed formats are &#x60;&#x60;JPG&#x60;&#x60;, &#x60;&#x60;JPEG&#x60;&#x60;, &#x60;&#x60;PNG&#x60;&#x60;. Max. file size is &#x60;&#x60;10Mb&#x60;&#x60;. Ensure that the file upload adheres to [RFC 2388](https://www.ietf.org/rfc/rfc2388.txt), which defines file transfers for the multipart/form-data protocol.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadProductPhoto(expedientNumber: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadProductPhoto(expedientNumber, file, options);
            const localVarOperationServerIndex = 0;
            const localVarOperationServerBasePath = operationServerMap['KloutitCaseApi.uploadProductPhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verifies if the webhook event received has been sent by Kloutit
         * @summary Verify webhook event
         * @param {ClientWebhookEventDto} clientWebhookEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyEvent(clientWebhookEventDto: ClientWebhookEventDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyEvent(clientWebhookEventDto, options);
            const localVarOperationServerIndex = 0;
            const localVarOperationServerBasePath = operationServerMap['KloutitCaseApi.verifyEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * KloutitCaseApi - factory interface
 * @export
 */
export const KloutitCaseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KloutitCaseApiFp(configuration)
    return {
        /**
         * Validates that the case has been updated with all the needed information. It indicates in the response if there are still some fields that could be informed to Kloutit before generating the dispute. It also informs the type and the required nature of each field.
         * @summary Check case information
         * @param {string} expedientNumber Case expedient number. This value must exist in Kloutit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkCase(expedientNumber: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.checkCase(expedientNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Case SDK call to create a new chargeback case from your system into Kloutit. API Key authentication is required in the x-api-key header.
         * @summary Create a new case into Kloutit.
         * @param {CreateCaseParams} createCaseParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCase(createCaseParams: CreateCaseParams, options?: RawAxiosRequestConfig): AxiosPromise<Case> {
            return localVarFp.createCase(createCaseParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads the case defense with the given format
         * @summary Download the case defense
         * @param {string} expedientNumber Case expedient number
         * @param {DownloadCaseDefenseFormatEnum} format Format parameter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCaseDefense(expedientNumber: string, format: DownloadCaseDefenseFormatEnum, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.downloadCaseDefense(expedientNumber, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Submits that the case has been updated with all the needed information. If you have configured automated dispute generation in Kloutit, this endpoint will indicate that the case is ready and will trigger the defense generation automatically.
         * @summary Submit completed case
         * @param {string} expedientNumber Case expedient number. This value must exist in Kloutit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitCompletedCase(expedientNumber: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.submitCompletedCase(expedientNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates data to enrich an existing case in order to generate a more complete defense and increase the chances of winning.
         * @summary Update case
         * @param {string} expedientNumber Case expedient number. This value must exist in Kloutit.
         * @param {UpdateCaseParams} updateCaseParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCase(expedientNumber: string, updateCaseParams: UpdateCaseParams, options?: RawAxiosRequestConfig): AxiosPromise<Case> {
            return localVarFp.updateCase(expedientNumber, updateCaseParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads a file into an existing case. You need to send a request of type ``multipart/form-data``. Allowed formats are ``PDF``, ``JPG``, ``JPEG``, ``PNG``. Max. file size is ``10Mb``
         * @summary Upload file
         * @param {string} expedientNumber 
         * @param {File} file A file to upload. Make sure that the specifications follow RFC 2388, which defines file transfers for the multipart/form-data protocol. Allowed formats are &#x60;&#x60;PDF&#x60;&#x60;, &#x60;&#x60;JPG&#x60;&#x60;, &#x60;&#x60;JPEG&#x60;&#x60;, &#x60;&#x60;PNG&#x60;&#x60;. Max. file size is &#x60;&#x60;10Mb&#x60;&#x60;. Ensure that the file upload adheres to [RFC 2388](https://www.ietf.org/rfc/rfc2388.txt), which defines file transfers for the multipart/form-data protocol.
         * @param {UploadFileCategoryEnum} category Category of the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(expedientNumber: string, file: File, category: UploadFileCategoryEnum, options?: RawAxiosRequestConfig): AxiosPromise<FileItem> {
            return localVarFp.uploadFile(expedientNumber, file, category, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads a product photo into an existing case. Only available for cases with sector MARKETPLACE. You need to send a request of type ``multipart/form-data``. This file can be attached only for marketplace company. Allowed formats are ``JPG``, ``JPEG``, ``PNG``. Max. file size is ``10Mb``
         * @summary Upload product photo
         * @param {string} expedientNumber 
         * @param {File} file A file to upload. Make sure that the specifications follow RFC 2388, which defines file transfers for the multipart/form-data protocol. Allowed formats are &#x60;&#x60;JPG&#x60;&#x60;, &#x60;&#x60;JPEG&#x60;&#x60;, &#x60;&#x60;PNG&#x60;&#x60;. Max. file size is &#x60;&#x60;10Mb&#x60;&#x60;. Ensure that the file upload adheres to [RFC 2388](https://www.ietf.org/rfc/rfc2388.txt), which defines file transfers for the multipart/form-data protocol.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProductPhoto(expedientNumber: string, file: File, options?: RawAxiosRequestConfig): AxiosPromise<FileItem> {
            return localVarFp.uploadProductPhoto(expedientNumber, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies if the webhook event received has been sent by Kloutit
         * @summary Verify webhook event
         * @param {ClientWebhookEventDto} clientWebhookEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEvent(clientWebhookEventDto: ClientWebhookEventDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.verifyEvent(clientWebhookEventDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KloutitCaseApi - object-oriented interface
 * @export
 * @class KloutitCaseApi
 * @extends {BaseAPI}
 */
export class KloutitCaseApi extends BaseAPI {
    /**
     * Validates that the case has been updated with all the needed information. It indicates in the response if there are still some fields that could be informed to Kloutit before generating the dispute. It also informs the type and the required nature of each field.
     * @summary Check case information
     * @param {string} expedientNumber Case expedient number. This value must exist in Kloutit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KloutitCaseApi
     */
    public checkCase(expedientNumber: string, options?: RawAxiosRequestConfig) {
        return KloutitCaseApiFp(this.configuration).checkCase(expedientNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Case SDK call to create a new chargeback case from your system into Kloutit. API Key authentication is required in the x-api-key header.
     * @summary Create a new case into Kloutit.
     * @param {CreateCaseParams} createCaseParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KloutitCaseApi
     */
    public createCase(createCaseParams: CreateCaseParams, options?: RawAxiosRequestConfig) {
        return KloutitCaseApiFp(this.configuration).createCase(createCaseParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Downloads the case defense with the given format
     * @summary Download the case defense
     * @param {string} expedientNumber Case expedient number
     * @param {DownloadCaseDefenseFormatEnum} format Format parameter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KloutitCaseApi
     */
    public downloadCaseDefense(expedientNumber: string, format: DownloadCaseDefenseFormatEnum, options?: RawAxiosRequestConfig) {
        return KloutitCaseApiFp(this.configuration).downloadCaseDefense(expedientNumber, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submits that the case has been updated with all the needed information. If you have configured automated dispute generation in Kloutit, this endpoint will indicate that the case is ready and will trigger the defense generation automatically.
     * @summary Submit completed case
     * @param {string} expedientNumber Case expedient number. This value must exist in Kloutit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KloutitCaseApi
     */
    public submitCompletedCase(expedientNumber: string, options?: RawAxiosRequestConfig) {
        return KloutitCaseApiFp(this.configuration).submitCompletedCase(expedientNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates data to enrich an existing case in order to generate a more complete defense and increase the chances of winning.
     * @summary Update case
     * @param {string} expedientNumber Case expedient number. This value must exist in Kloutit.
     * @param {UpdateCaseParams} updateCaseParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KloutitCaseApi
     */
    public updateCase(expedientNumber: string, updateCaseParams: UpdateCaseParams, options?: RawAxiosRequestConfig) {
        return KloutitCaseApiFp(this.configuration).updateCase(expedientNumber, updateCaseParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads a file into an existing case. You need to send a request of type ``multipart/form-data``. Allowed formats are ``PDF``, ``JPG``, ``JPEG``, ``PNG``. Max. file size is ``10Mb``
     * @summary Upload file
     * @param {string} expedientNumber 
     * @param {File} file A file to upload. Make sure that the specifications follow RFC 2388, which defines file transfers for the multipart/form-data protocol. Allowed formats are &#x60;&#x60;PDF&#x60;&#x60;, &#x60;&#x60;JPG&#x60;&#x60;, &#x60;&#x60;JPEG&#x60;&#x60;, &#x60;&#x60;PNG&#x60;&#x60;. Max. file size is &#x60;&#x60;10Mb&#x60;&#x60;. Ensure that the file upload adheres to [RFC 2388](https://www.ietf.org/rfc/rfc2388.txt), which defines file transfers for the multipart/form-data protocol.
     * @param {UploadFileCategoryEnum} category Category of the file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KloutitCaseApi
     */
    public uploadFile(expedientNumber: string, file: File, category: UploadFileCategoryEnum, options?: RawAxiosRequestConfig) {
        return KloutitCaseApiFp(this.configuration).uploadFile(expedientNumber, file, category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads a product photo into an existing case. Only available for cases with sector MARKETPLACE. You need to send a request of type ``multipart/form-data``. This file can be attached only for marketplace company. Allowed formats are ``JPG``, ``JPEG``, ``PNG``. Max. file size is ``10Mb``
     * @summary Upload product photo
     * @param {string} expedientNumber 
     * @param {File} file A file to upload. Make sure that the specifications follow RFC 2388, which defines file transfers for the multipart/form-data protocol. Allowed formats are &#x60;&#x60;JPG&#x60;&#x60;, &#x60;&#x60;JPEG&#x60;&#x60;, &#x60;&#x60;PNG&#x60;&#x60;. Max. file size is &#x60;&#x60;10Mb&#x60;&#x60;. Ensure that the file upload adheres to [RFC 2388](https://www.ietf.org/rfc/rfc2388.txt), which defines file transfers for the multipart/form-data protocol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KloutitCaseApi
     */
    public uploadProductPhoto(expedientNumber: string, file: File, options?: RawAxiosRequestConfig) {
        return KloutitCaseApiFp(this.configuration).uploadProductPhoto(expedientNumber, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verifies if the webhook event received has been sent by Kloutit
     * @summary Verify webhook event
     * @param {ClientWebhookEventDto} clientWebhookEventDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KloutitCaseApi
     */
    public verifyEvent(clientWebhookEventDto: ClientWebhookEventDto, options?: RawAxiosRequestConfig) {
        return KloutitCaseApiFp(this.configuration).verifyEvent(clientWebhookEventDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DownloadCaseDefenseFormatEnum = {
    PDF: 'PDF',
    DOCX: 'DOCX'
} as const;
export type DownloadCaseDefenseFormatEnum = typeof DownloadCaseDefenseFormatEnum[keyof typeof DownloadCaseDefenseFormatEnum];
/**
 * @export
 */
export const UploadFileCategoryEnum = {
    RECEIPT: 'RECEIPT',
    CUSTOMER_COMMUNICATION: 'CUSTOMER_COMMUNICATION',
    CUSTOMER_SIGNATURE: 'CUSTOMER_SIGNATURE',
    PAYMENT_AUTHORIZATION: 'PAYMENT_AUTHORIZATION',
    CUSTOMER_VISUAL_EVIDENCE: 'CUSTOMER_VISUAL_EVIDENCE',
    CUSTOMER_UNCATEGORIZED_FILE: 'CUSTOMER_UNCATEGORIZED_FILE',
    CANCELLATION_POLICY: 'CANCELLATION_POLICY',
    REFUND_POLICY: 'REFUND_POLICY',
    REFUND_EVIDENCE: 'REFUND_EVIDENCE',
    TERMS_AND_CONDITIONS: 'TERMS_AND_CONDITIONS',
    DUPLICATE_CHARGE_DOCUMENTATION: 'DUPLICATE_CHARGE_DOCUMENTATION',
    SERVICE_EVIDENCE: 'SERVICE_EVIDENCE',
    SHIPPING_EVIDENCE: 'SHIPPING_EVIDENCE',
    COMPANY_VISUAL_EVIDENCE: 'COMPANY_VISUAL_EVIDENCE',
    COMPANY_UNCATEGORIZED_FILE: 'COMPANY_UNCATEGORIZED_FILE'
} as const;
export type UploadFileCategoryEnum = typeof UploadFileCategoryEnum[keyof typeof UploadFileCategoryEnum];


