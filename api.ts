/* tslint:disable */
/* eslint-disable */
/**
 * Kloutit Clients API
 * Kloutit list of Client API calls
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AmountDto
 */
export interface AmountDto {
    /**
     * 
     * @type {number}
     * @memberof AmountDto
     */
    'value': number;
    /**
     * 
     * @type {string}
     * @memberof AmountDto
     */
    'currency': string;
    /**
     * 
     * @type {number}
     * @memberof AmountDto
     */
    'conversionRate'?: number;
}
/**
 * 
 * @export
 * @interface CommunicationItemDto
 */
export interface CommunicationItemDto {
    /**
     * 
     * @type {string}
     * @memberof CommunicationItemDto
     */
    'sender': string;
    /**
     * 
     * @type {string}
     * @memberof CommunicationItemDto
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof CommunicationItemDto
     */
    'date': string;
}
/**
 * 
 * @export
 * @interface KloutitCaseBody
 */
export interface KloutitCaseBody {
    /**
     * 
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof KloutitCaseBody
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof KloutitCaseBody
     */
    'isDeleted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'deletedAt'?: string;
    /**
     * Date when the customer made the purchase.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'purchaseDate': string;
    /**
     * Service that the customer bought.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'service'?: string;
    /**
     * Product that the customer bought.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'product'?: string;
    /**
     * Flag that indicates if the charge made is refundable regarding your company terms and conditions.
     * @type {boolean}
     * @memberof KloutitCaseBody
     */
    'isChargeRefundable': boolean;
    /**
     * Customer name.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'customerName': string;
    /**
     * Customer email
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'customerEmail': string;
    /**
     * Customer phone.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'customerPhone'?: string;
    /**
     * Date when the serve was provided or will be provided.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'serviceDate'?: string;
    /**
     * Flag that indicates if the service was provided or not.
     * @type {boolean}
     * @memberof KloutitCaseBody
     */
    'serviceWasProvided'?: boolean;
    /**
     * Check in date.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'checkinDate'?: string;
    /**
     * Check out date.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'checkoutDate'?: string;
    /**
     * Hotel name.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'hotelName'?: string;
    /**
     * Rate applied.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'rate'?: string;
    /**
     * Flag that indicates if the client made the checkin or not.
     * @type {boolean}
     * @memberof KloutitCaseBody
     */
    'checkinConfirmation'?: boolean;
    /**
     * Destination country.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'destinationCountry'?: string;
    /**
     * Departure date.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'departureDate'?: string;
    /**
     * Arrival date.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'arrivalDate'?: string;
    /**
     * Departure airport.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'departureAirport'?: string;
    /**
     * Arrival airport.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'arrivalAirport'?: string;
    /**
     * Shipping city.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'shippingCity'?: string;
    /**
     * Shipping province.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'shippingProvince'?: string;
    /**
     * Shipping postal code.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'shippingPostalCode'?: string;
    /**
     * Shipping date.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'shippingDate'?: string;
    /**
     * Delivery date.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'deliveryDate'?: string;
    /**
     * Delivery company.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'deliveryCompany'?: string;
    /**
     * Flag that indicates if the customer received the product.
     * @type {boolean}
     * @memberof KloutitCaseBody
     */
    'deliveryConfirmation'?: boolean;
    /**
     * Start date of the commitment that the customer has with the company.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'commitmentStartDate'?: string;
    /**
     * End date of the commitment that the customer has with the company.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'commitmentEndDate'?: string;
    /**
     * Chargeback expedient number.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'expedientNumber': string;
    /**
     * Chargeback notification date, when the merchant receives the chargeback notification.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'notificationDate': string;
    /**
     * Amount that the customer claims.
     * @type {AmountDto}
     * @memberof KloutitCaseBody
     */
    'disputeAmount': AmountDto;
    /**
     * Reason why the customer is requesting the chargeback.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'chargebackReason': KloutitCaseBodyChargebackReasonEnum;
    /**
     * Deadline date to resolve this chargeback.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'deadline'?: string;
    /**
     * Date when the customer contacted to the merchant.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'contactDate'?: string;
    /**
     * Array of all the emails that the customer has sent regarding this dispute.
     * @type {Array<CommunicationItemDto>}
     * @memberof KloutitCaseBody
     */
    'communications'?: Array<CommunicationItemDto>;
    /**
     * Additional info related to the chargeback.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'additionalInfo'?: string;
    /**
     * Holder credit card number.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'panNumber'?: string;
    /**
     * Transaction id.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'transactionId'?: string;
    /**
     * Transaction date.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'transactionDate': string;
    /**
     * Purchase amount.
     * @type {AmountDto}
     * @memberof KloutitCaseBody
     */
    'purchaseAmount': AmountDto;
    /**
     * Customer bank name.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'bankName'?: string;
    /**
     * Card brand that the customer used to make the payment.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'cardBrand'?: string;
    /**
     * Flag that indicates if the purchase has been made with 3DS.
     * @type {boolean}
     * @memberof KloutitCaseBody
     */
    'is3DSPurchase': boolean;
    /**
     * Sector of the case. It must be one of the sectors of the organization, for instance: EDUCATION, SOFTWARE, TRAVEL_HOTEL,...
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'organizationType': KloutitCaseBodyOrganizationTypeEnum;
    /**
     * Your organization id.
     * @type {string}
     * @memberof KloutitCaseBody
     */
    'organizationId': string;
}

export const KloutitCaseBodyChargebackReasonEnum = {
    Fraud: 'FRAUD',
    ProductServiceNotReceived: 'PRODUCT_SERVICE_NOT_RECEIVED',
    DefectiveProductService: 'DEFECTIVE_PRODUCT_SERVICE',
    ProductServiceNotAsDescribed: 'PRODUCT_SERVICE_NOT_AS_DESCRIBED',
    IncorrectDuplicatedCharges: 'INCORRECT_DUPLICATED_CHARGES',
    ProductServiceCancelled: 'PRODUCT_SERVICE_CANCELLED',
    RefundNotReceived: 'REFUND_NOT_RECEIVED',
    RecurrentOperationCancelled: 'RECURRENT_OPERATION_CANCELLED'
} as const;

export type KloutitCaseBodyChargebackReasonEnum = typeof KloutitCaseBodyChargebackReasonEnum[keyof typeof KloutitCaseBodyChargebackReasonEnum];
export const KloutitCaseBodyOrganizationTypeEnum = {
    Education: 'EDUCATION',
    Fashion: 'FASHION',
    Food: 'FOOD',
    Gaming: 'GAMING',
    HealthBeauty: 'HEALTH_BEAUTY',
    Home: 'HOME',
    Leisure: 'LEISURE',
    Phone: 'PHONE',
    Software: 'SOFTWARE',
    Sport: 'SPORT',
    Supply: 'SUPPLY',
    Technology: 'TECHNOLOGY',
    TravelAirline: 'TRAVEL_AIRLINE',
    TravelHotel: 'TRAVEL_HOTEL'
} as const;

export type KloutitCaseBodyOrganizationTypeEnum = typeof KloutitCaseBodyOrganizationTypeEnum[keyof typeof KloutitCaseBodyOrganizationTypeEnum];

/**
 * 
 * @export
 * @interface KloutitCaseResponse
 */
export interface KloutitCaseResponse {
    /**
     * 
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof KloutitCaseResponse
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof KloutitCaseResponse
     */
    'isDeleted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'deletedAt'?: string;
    /**
     * Date when the customer made the purchase.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'purchaseDate': string;
    /**
     * Service that the customer bought.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'service'?: string;
    /**
     * Product that the customer bought.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'product'?: string;
    /**
     * Flag that indicates if the charge made is refundable regarding your company terms and conditions.
     * @type {boolean}
     * @memberof KloutitCaseResponse
     */
    'isChargeRefundable': boolean;
    /**
     * Customer name.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'customerName': string;
    /**
     * Customer email
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'customerEmail': string;
    /**
     * Customer phone.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'customerPhone'?: string;
    /**
     * Date when the serve was provided or will be provided.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'serviceDate'?: string;
    /**
     * Flag that indicates if the service was provided or not.
     * @type {boolean}
     * @memberof KloutitCaseResponse
     */
    'serviceWasProvided'?: boolean;
    /**
     * Check in date.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'checkinDate'?: string;
    /**
     * Check out date.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'checkoutDate'?: string;
    /**
     * Hotel name.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'hotelName'?: string;
    /**
     * Rate applied.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'rate'?: string;
    /**
     * Flag that indicates if the client made the checkin or not.
     * @type {boolean}
     * @memberof KloutitCaseResponse
     */
    'checkinConfirmation'?: boolean;
    /**
     * Destination country.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'destinationCountry'?: string;
    /**
     * Departure date.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'departureDate'?: string;
    /**
     * Arrival date.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'arrivalDate'?: string;
    /**
     * Departure airport.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'departureAirport'?: string;
    /**
     * Arrival airport.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'arrivalAirport'?: string;
    /**
     * Shipping city.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'shippingCity'?: string;
    /**
     * Shipping province.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'shippingProvince'?: string;
    /**
     * Shipping postal code.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'shippingPostalCode'?: string;
    /**
     * Shipping date.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'shippingDate'?: string;
    /**
     * Delivery date.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'deliveryDate'?: string;
    /**
     * Delivery company.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'deliveryCompany'?: string;
    /**
     * Flag that indicates if the customer received the product.
     * @type {boolean}
     * @memberof KloutitCaseResponse
     */
    'deliveryConfirmation'?: boolean;
    /**
     * Start date of the commitment that the customer has with the company.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'commitmentStartDate'?: string;
    /**
     * End date of the commitment that the customer has with the company.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'commitmentEndDate'?: string;
    /**
     * Chargeback expedient number.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'expedientNumber': string;
    /**
     * Chargeback notification date, when the merchant receives the chargeback notification.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'notificationDate': string;
    /**
     * Amount that the customer claims.
     * @type {AmountDto}
     * @memberof KloutitCaseResponse
     */
    'disputeAmount': AmountDto;
    /**
     * Reason why the customer is requesting the chargeback.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'chargebackReason': string;
    /**
     * Deadline date to resolve this chargeback.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'deadline'?: string;
    /**
     * Date when the customer contacted to the merchant.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'contactDate'?: string;
    /**
     * Array of all the emails that the customer has sent regarding this dispute.
     * @type {Array<CommunicationItemDto>}
     * @memberof KloutitCaseResponse
     */
    'communications'?: Array<CommunicationItemDto>;
    /**
     * Additional info related to the chargeback.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'additionalInfo'?: string;
    /**
     * Holder credit card number.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'panNumber'?: string;
    /**
     * Transaction id.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'transactionId'?: string;
    /**
     * Transaction date.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'transactionDate': string;
    /**
     * Purchase amount.
     * @type {AmountDto}
     * @memberof KloutitCaseResponse
     */
    'purchaseAmount': AmountDto;
    /**
     * Customer bank name.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'bankName'?: string;
    /**
     * Card brand that the customer used to make the payment.
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'cardBrand'?: string;
    /**
     * Flag that indicates if the purchase has been made with 3DS.
     * @type {boolean}
     * @memberof KloutitCaseResponse
     */
    'is3DSPurchase': boolean;
    /**
     * Sector of the case. It must be one of the sectors of the organization, for instance: EDUCATION, SOFTWARE, TRAVEL_HOTEL,...
     * @type {string}
     * @memberof KloutitCaseResponse
     */
    'organizationType': KloutitCaseResponseOrganizationTypeEnum;
    /**
     * 
     * @type {OrganizationDto}
     * @memberof KloutitCaseResponse
     */
    'organization'?: OrganizationDto;
    /**
     * 
     * @type {object}
     * @memberof KloutitCaseResponse
     */
    'dispute'?: object;
}

export const KloutitCaseResponseOrganizationTypeEnum = {
    Education: 'EDUCATION',
    Fashion: 'FASHION',
    Food: 'FOOD',
    Gaming: 'GAMING',
    HealthBeauty: 'HEALTH_BEAUTY',
    Home: 'HOME',
    Leisure: 'LEISURE',
    Phone: 'PHONE',
    Software: 'SOFTWARE',
    Sport: 'SPORT',
    Supply: 'SUPPLY',
    Technology: 'TECHNOLOGY',
    TravelAirline: 'TRAVEL_AIRLINE',
    TravelHotel: 'TRAVEL_HOTEL'
} as const;

export type KloutitCaseResponseOrganizationTypeEnum = typeof KloutitCaseResponseOrganizationTypeEnum[keyof typeof KloutitCaseResponseOrganizationTypeEnum];

/**
 * 
 * @export
 * @interface KloutitLoginBody
 */
export interface KloutitLoginBody {
    /**
     * Grant type used to get access token.
     * @type {string}
     * @memberof KloutitLoginBody
     */
    'grant_type': string;
}
/**
 * 
 * @export
 * @interface KloutitLoginClient
 */
export interface KloutitLoginClient {
    /**
     * Your organization id.
     * @type {string}
     * @memberof KloutitLoginClient
     */
    'organizationId': string;
}
/**
 * 
 * @export
 * @interface KloutitLoginResponse
 */
export interface KloutitLoginResponse {
    /**
     * Access token.
     * @type {string}
     * @memberof KloutitLoginResponse
     */
    'accessToken': string;
    /**
     * Token validity time in seconds.
     * @type {number}
     * @memberof KloutitLoginResponse
     */
    'expiresIn': number;
    /**
     * Token expiration time.
     * @type {number}
     * @memberof KloutitLoginResponse
     */
    'expiresAt': number;
    /**
     * 
     * @type {KloutitLoginClient}
     * @memberof KloutitLoginResponse
     */
    'client': KloutitLoginClient;
}
/**
 * 
 * @export
 * @interface OrganizationDto
 */
export interface OrganizationDto {
    /**
     * 
     * @type {string}
     * @memberof OrganizationDto
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationDto
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDto
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationDto
     */
    'isDeleted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDto
     */
    'deletedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDto
     */
    'cif': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDto
     */
    'billingAddress': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof OrganizationDto
     */
    'type': Array<OrganizationDtoTypeEnum>;
    /**
     * 
     * @type {object}
     * @memberof OrganizationDto
     */
    'size': object;
    /**
     * 
     * @type {object}
     * @memberof OrganizationDto
     */
    'subscriptionStatus': object;
    /**
     * 
     * @type {object}
     * @memberof OrganizationDto
     */
    'subscriptionPlan'?: object;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDto
     */
    'termsLink': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDto
     */
    'website': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDto
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDto
     */
    'preferredCurrency': string;
    /**
     * 
     * @type {object}
     * @memberof OrganizationDto
     */
    'language': object;
}

export const OrganizationDtoTypeEnum = {
    Education: 'EDUCATION',
    Fashion: 'FASHION',
    Food: 'FOOD',
    Gaming: 'GAMING',
    HealthBeauty: 'HEALTH_BEAUTY',
    Home: 'HOME',
    Leisure: 'LEISURE',
    Phone: 'PHONE',
    Software: 'SOFTWARE',
    Sport: 'SPORT',
    Supply: 'SUPPLY',
    Technology: 'TECHNOLOGY',
    TravelAirline: 'TRAVEL_AIRLINE',
    TravelHotel: 'TRAVEL_HOTEL'
} as const;

export type OrganizationDtoTypeEnum = typeof OrganizationDtoTypeEnum[keyof typeof OrganizationDtoTypeEnum];


/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthControllerHealth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthControllerHealth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.healthControllerHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerHealth(options?: any): AxiosPromise<void> {
            return localVarFp.healthControllerHealth(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @summary Health check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public healthControllerHealth(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthControllerHealth(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * KloutitCaseApi - axios parameter creator
 * @export
 */
export const KloutitCaseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Case SDK call to create a new chargeback case from your system into Kloutit. Authentication header `Bearer {token}` is needed, where the token has been retrieved using the login API.
         * @summary Create a new case into Kloutit.
         * @param {KloutitCaseBody} kloutitCaseBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCase: async (kloutitCaseBody: KloutitCaseBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'kloutitCaseBody' is not null or undefined
            assertParamExists('createCase', 'kloutitCaseBody', kloutitCaseBody)
            const localVarPath = `/case`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(kloutitCaseBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KloutitCaseApi - functional programming interface
 * @export
 */
export const KloutitCaseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KloutitCaseApiAxiosParamCreator(configuration)
    return {
        /**
         * Case SDK call to create a new chargeback case from your system into Kloutit. Authentication header `Bearer {token}` is needed, where the token has been retrieved using the login API.
         * @summary Create a new case into Kloutit.
         * @param {KloutitCaseBody} kloutitCaseBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCase(kloutitCaseBody: KloutitCaseBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KloutitCaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCase(kloutitCaseBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KloutitCaseApi.createCase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * KloutitCaseApi - factory interface
 * @export
 */
export const KloutitCaseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KloutitCaseApiFp(configuration)
    return {
        /**
         * Case SDK call to create a new chargeback case from your system into Kloutit. Authentication header `Bearer {token}` is needed, where the token has been retrieved using the login API.
         * @summary Create a new case into Kloutit.
         * @param {KloutitCaseBody} kloutitCaseBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCase(kloutitCaseBody: KloutitCaseBody, options?: any): AxiosPromise<KloutitCaseResponse> {
            return localVarFp.createCase(kloutitCaseBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KloutitCaseApi - object-oriented interface
 * @export
 * @class KloutitCaseApi
 * @extends {BaseAPI}
 */
export class KloutitCaseApi extends BaseAPI {
    /**
     * Case SDK call to create a new chargeback case from your system into Kloutit. Authentication header `Bearer {token}` is needed, where the token has been retrieved using the login API.
     * @summary Create a new case into Kloutit.
     * @param {KloutitCaseBody} kloutitCaseBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KloutitCaseApi
     */
    public createCase(kloutitCaseBody: KloutitCaseBody, options?: RawAxiosRequestConfig) {
        return KloutitCaseApiFp(this.configuration).createCase(kloutitCaseBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * KloutitLoginApi - axios parameter creator
 * @export
 */
export const KloutitLoginApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Login SDK call to get an access token that could be used for other calls that need bearer authentication. We strongly recommend to store the retrieved access token into some cache, so it would not be generated on each call. The token can be used as many times as you want until is not expires. Then a new one must be generated. Authentication header `Basic {token}` is needed, where basic token is generated in base64 using `{clientId}:{clientSecret}`
         * @summary Get access token.
         * @param {string} organizationId Organization id
         * @param {KloutitLoginBody} kloutitLoginBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (organizationId: string, kloutitLoginBody: KloutitLoginBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('login', 'organizationId', organizationId)
            // verify required parameter 'kloutitLoginBody' is not null or undefined
            assertParamExists('login', 'kloutitLoginBody', kloutitLoginBody)
            const localVarPath = `/clients/{organizationId}/login`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(kloutitLoginBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KloutitLoginApi - functional programming interface
 * @export
 */
export const KloutitLoginApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KloutitLoginApiAxiosParamCreator(configuration)
    return {
        /**
         * Login SDK call to get an access token that could be used for other calls that need bearer authentication. We strongly recommend to store the retrieved access token into some cache, so it would not be generated on each call. The token can be used as many times as you want until is not expires. Then a new one must be generated. Authentication header `Basic {token}` is needed, where basic token is generated in base64 using `{clientId}:{clientSecret}`
         * @summary Get access token.
         * @param {string} organizationId Organization id
         * @param {KloutitLoginBody} kloutitLoginBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(organizationId: string, kloutitLoginBody: KloutitLoginBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KloutitLoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(organizationId, kloutitLoginBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KloutitLoginApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * KloutitLoginApi - factory interface
 * @export
 */
export const KloutitLoginApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KloutitLoginApiFp(configuration)
    return {
        /**
         * Login SDK call to get an access token that could be used for other calls that need bearer authentication. We strongly recommend to store the retrieved access token into some cache, so it would not be generated on each call. The token can be used as many times as you want until is not expires. Then a new one must be generated. Authentication header `Basic {token}` is needed, where basic token is generated in base64 using `{clientId}:{clientSecret}`
         * @summary Get access token.
         * @param {string} organizationId Organization id
         * @param {KloutitLoginBody} kloutitLoginBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(organizationId: string, kloutitLoginBody: KloutitLoginBody, options?: any): AxiosPromise<KloutitLoginResponse> {
            return localVarFp.login(organizationId, kloutitLoginBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KloutitLoginApi - object-oriented interface
 * @export
 * @class KloutitLoginApi
 * @extends {BaseAPI}
 */
export class KloutitLoginApi extends BaseAPI {
    /**
     * Login SDK call to get an access token that could be used for other calls that need bearer authentication. We strongly recommend to store the retrieved access token into some cache, so it would not be generated on each call. The token can be used as many times as you want until is not expires. Then a new one must be generated. Authentication header `Basic {token}` is needed, where basic token is generated in base64 using `{clientId}:{clientSecret}`
     * @summary Get access token.
     * @param {string} organizationId Organization id
     * @param {KloutitLoginBody} kloutitLoginBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KloutitLoginApi
     */
    public login(organizationId: string, kloutitLoginBody: KloutitLoginBody, options?: RawAxiosRequestConfig) {
        return KloutitLoginApiFp(this.configuration).login(organizationId, kloutitLoginBody, options).then((request) => request(this.axios, this.basePath));
    }
}



