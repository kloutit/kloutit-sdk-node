/* tslint:disable */
/* eslint-disable */
/**
 * API Reference
 * The Kloutit API is organized around [REST](https://en.wikipedia.org/wiki/REST), it accepts and returns [JSON-encoded](https://www.json.org) bodies, returning standard [HTTP response codes](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes). You can interact with the API directly using your preferred HTTP/REST library.
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, BaseAPI, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Amount
 */
export interface Amount {
    /**
     * 
     * @type {number}
     * @memberof Amount
     */
    'value': number;
    /**
     * 
     * @type {Currencies}
     * @memberof Amount
     */
    'currency': Currencies;
}


/**
 * 
 * @export
 * @interface Case
 */
export interface Case {
    /**
     * 
     * @type {string}
     * @memberof Case
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Case
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Case
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Case
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Case
     */
    'isDeleted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Case
     */
    'deletedAt'?: string;
    /**
     * 
     * @type {CaseStatus}
     * @memberof Case
     */
    'status': CaseStatus;
    /**
     * Filial identifier related to the case.
     * @type {string}
     * @memberof Case
     */
    'filialIdentifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof Case
     */
    'paymentProcessor'?: CasePaymentProcessorEnum;
    /**
     * Date when the customer made the purchase in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'purchaseDate': string;
    /**
     * Service that the customer bought.
     * @type {string}
     * @memberof Case
     */
    'service'?: string;
    /**
     * Product that the customer bought.
     * @type {string}
     * @memberof Case
     */
    'product'?: string;
    /**
     * Flag that indicates if the charge made is refundable regarding your company terms and conditions.
     * @type {boolean}
     * @memberof Case
     */
    'isChargeRefundable': boolean;
    /**
     * Customer name.
     * @type {string}
     * @memberof Case
     */
    'customerName'?: string;
    /**
     * Customer email
     * @type {string}
     * @memberof Case
     */
    'customerEmail'?: string;
    /**
     * Customer phone.
     * @type {string}
     * @memberof Case
     */
    'customerPhone'?: string;
    /**
     * Date when the service was provided or will be provided in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'serviceDate'?: string;
    /**
     * Flag that indicates if the service was provided or not.
     * @type {boolean}
     * @memberof Case
     */
    'serviceWasProvided'?: boolean;
    /**
     * Check in date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'checkinDate'?: string;
    /**
     * Check out date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'checkoutDate'?: string;
    /**
     * Hotel name.
     * @type {string}
     * @memberof Case
     */
    'hotelName'?: string;
    /**
     * Rate applied.
     * @type {string}
     * @memberof Case
     */
    'rate'?: string;
    /**
     * Flag that indicates if the client made the checkin or not.
     * @type {boolean}
     * @memberof Case
     */
    'checkinConfirmation'?: boolean;
    /**
     * Destination country.
     * @type {string}
     * @memberof Case
     */
    'destinationCountry'?: string;
    /**
     * Departure date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'departureDate'?: string;
    /**
     * Arrival date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'arrivalDate'?: string;
    /**
     * Departure airport.
     * @type {string}
     * @memberof Case
     */
    'departureAirport'?: string;
    /**
     * Arrival airport.
     * @type {string}
     * @memberof Case
     */
    'arrivalAirport'?: string;
    /**
     * Departure city.
     * @type {string}
     * @memberof Case
     */
    'departureCity'?: string;
    /**
     * Arrival city.
     * @type {string}
     * @memberof Case
     */
    'arrivalCity'?: string;
    /**
     * Shipping city.
     * @type {string}
     * @memberof Case
     */
    'shippingCity'?: string;
    /**
     * Shipping province.
     * @type {string}
     * @memberof Case
     */
    'shippingProvince'?: string;
    /**
     * Shipping postal code.
     * @type {string}
     * @memberof Case
     */
    'shippingPostalCode'?: string;
    /**
     * Shipping date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'shippingDate'?: string;
    /**
     * Delivery date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'deliveryDate'?: string;
    /**
     * Delivery company.
     * @type {string}
     * @memberof Case
     */
    'deliveryCompany'?: string;
    /**
     * Flag that indicates if the customer received the product.
     * @type {boolean}
     * @memberof Case
     */
    'deliveryConfirmation'?: boolean;
    /**
     * Start date in UTC and ISO 8601 format of the commitment that the customer has with the company.
     * @type {string}
     * @memberof Case
     */
    'commitmentStartDate'?: string;
    /**
     * End date in UTC and ISO 8601 format of the commitment that the customer has with the company.
     * @type {string}
     * @memberof Case
     */
    'commitmentEndDate'?: string;
    /**
     * Flag that indicates if the subscription is cancelled or active.
     * @type {boolean}
     * @memberof Case
     */
    'isCancelled'?: boolean;
    /**
     * Product description.
     * @type {string}
     * @memberof Case
     */
    'productDescription'?: string;
    /**
     * Chargeback expedient number.
     * @type {string}
     * @memberof Case
     */
    'expedientNumber': string;
    /**
     * Chargeback notification date, when the merchant receives the chargeback notification, in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'notificationDate': string;
    /**
     * 
     * @type {CaseDisputeAmount}
     * @memberof Case
     */
    'disputeAmount': CaseDisputeAmount;
    /**
     * 
     * @type {ChargebackReason}
     * @memberof Case
     */
    'chargebackReason': ChargebackReason;
    /**
     * Deadline date to resolve this chargeback in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'deadline'?: string;
    /**
     * Date when the customer contacted to the merchant in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'contactDate'?: string;
    /**
     * Array of all the emails that the customer has sent regarding this dispute. The structure of each item contains: **sender**: *customer* or *company*, **date**, **content**: string containing the message
     * @type {Array<CommunicationItem>}
     * @memberof Case
     */
    'communications'?: Array<CommunicationItem>;
    /**
     * Additional info related to the chargeback.
     * @type {string}
     * @memberof Case
     */
    'additionalInfo'?: string;
    /**
     * Last 4 digits of the customer\'s credit card number.
     * @type {string}
     * @memberof Case
     */
    'last4Digits'?: string;
    /**
     * Transaction id.
     * @type {string}
     * @memberof Case
     */
    'transactionId'?: string;
    /**
     * Transaction date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'transactionDate': string;
    /**
     * Purchase amount.
     * @type {Amount}
     * @memberof Case
     */
    'purchaseAmount': Amount;
    /**
     * Customer bank name.
     * @type {string}
     * @memberof Case
     */
    'bankName'?: string;
    /**
     * Card brand that the customer used to make the payment.
     * @type {string}
     * @memberof Case
     */
    'cardBrand'?: string;
    /**
     * Flag that indicates if the purchase has been made with 3DS.
     * @type {boolean}
     * @memberof Case
     */
    'is3DSPurchase'?: boolean;
    /**
     * Organization sector of the case.
     * @type {string}
     * @memberof Case
     */
    'sector'?: CaseSectorEnum;
    /**
     * Date when the customer contacted to the seller in UTC and ISO 8601 format.
     * @type {string}
     * @memberof Case
     */
    'sellerContactDate'?: string;
    /**
     * Seller additional infromation.
     * @type {string}
     * @memberof Case
     */
    'sellerAdditionalInfo'?: string;
    /**
     * Seller name.
     * @type {string}
     * @memberof Case
     */
    'sellerName'?: string;
    /**
     * Seller phone number.
     * @type {string}
     * @memberof Case
     */
    'sellerPhone'?: string;
    /**
     * Seller email.
     * @type {string}
     * @memberof Case
     */
    'sellerEmail'?: string;
}

export const CasePaymentProcessorEnum = {
    Stripe: 'STRIPE',
    CheckoutCom: 'CHECKOUT_COM',
    Worldline: 'WORLDLINE',
    Redsys: 'REDSYS',
    Paypal: 'PAYPAL',
    Mangopay: 'MANGOPAY',
    Adyen: 'ADYEN'
} as const;

export type CasePaymentProcessorEnum = typeof CasePaymentProcessorEnum[keyof typeof CasePaymentProcessorEnum];
export const CaseSectorEnum = {
    DigitalProduct: 'DIGITAL_PRODUCT',
    Education: 'EDUCATION',
    Fashion: 'FASHION',
    Food: 'FOOD',
    Gaming: 'GAMING',
    HealthBeauty: 'HEALTH_BEAUTY',
    Home: 'HOME',
    Leisure: 'LEISURE',
    Marketplace: 'MARKETPLACE',
    Phone: 'PHONE',
    Software: 'SOFTWARE',
    Sport: 'SPORT',
    Subscription: 'SUBSCRIPTION',
    Supply: 'SUPPLY',
    Technology: 'TECHNOLOGY',
    Transport: 'TRANSPORT',
    TravelAirline: 'TRAVEL_AIRLINE',
    TravelHotel: 'TRAVEL_HOTEL'
} as const;

export type CaseSectorEnum = typeof CaseSectorEnum[keyof typeof CaseSectorEnum];

/**
 * Amount that the customer claims.
 * @export
 * @interface CaseDisputeAmount
 */
export interface CaseDisputeAmount {
    /**
     * 
     * @type {number}
     * @memberof CaseDisputeAmount
     */
    'value': number;
    /**
     * 
     * @type {Currencies}
     * @memberof CaseDisputeAmount
     */
    'currency': Currencies;
}


/**
 * Sector of the case. It must be one of the sectors of the organization, for instance: EDUCATION, SOFTWARE, TRAVEL_HOTEL,...
 * @export
 * @enum {string}
 */

export const CaseSector = {
    DigitalProduct: 'DIGITAL_PRODUCT',
    Education: 'EDUCATION',
    Fashion: 'FASHION',
    Food: 'FOOD',
    Gaming: 'GAMING',
    HealthBeauty: 'HEALTH_BEAUTY',
    Home: 'HOME',
    Leisure: 'LEISURE',
    Marketplace: 'MARKETPLACE',
    Phone: 'PHONE',
    Software: 'SOFTWARE',
    Sport: 'SPORT',
    Subscription: 'SUBSCRIPTION',
    Supply: 'SUPPLY',
    Technology: 'TECHNOLOGY',
    Transport: 'TRANSPORT',
    TravelAirline: 'TRAVEL_AIRLINE',
    TravelHotel: 'TRAVEL_HOTEL'
} as const;

export type CaseSector = typeof CaseSector[keyof typeof CaseSector];


/**
 * Current status of the case.
 * @export
 * @enum {string}
 */

export const CaseStatus = {
    Pending: 'PENDING',
    Generating: 'GENERATING',
    Generated: 'GENERATED',
    Alleging: 'ALLEGING',
    Alleged: 'ALLEGED',
    Won: 'WON',
    Lost: 'LOST',
    Accepted: 'ACCEPTED',
    Expired: 'EXPIRED'
} as const;

export type CaseStatus = typeof CaseStatus[keyof typeof CaseStatus];


/**
 * Reason why the customer is requesting the chargeback.
 * @export
 * @enum {string}
 */

export const ChargebackReason = {
    Fraud: 'FRAUD',
    ProductServiceNotReceived: 'PRODUCT_SERVICE_NOT_RECEIVED',
    DefectiveProductService: 'DEFECTIVE_PRODUCT_SERVICE',
    ProductServiceNotAsDescribed: 'PRODUCT_SERVICE_NOT_AS_DESCRIBED',
    IncorrectDuplicatedCharges: 'INCORRECT_DUPLICATED_CHARGES',
    ProductServiceCancelled: 'PRODUCT_SERVICE_CANCELLED',
    RefundNotReceived: 'REFUND_NOT_RECEIVED',
    RecurrentOperationCancelled: 'RECURRENT_OPERATION_CANCELLED'
} as const;

export type ChargebackReason = typeof ChargebackReason[keyof typeof ChargebackReason];


/**
 * 
 * @export
 * @interface CommunicationItem
 */
export interface CommunicationItem {
    /**
     * 
     * @type {string}
     * @memberof CommunicationItem
     */
    'sender': string;
    /**
     * 
     * @type {string}
     * @memberof CommunicationItem
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof CommunicationItem
     */
    'date': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Currencies = {
    Eur: 'EUR',
    Gbp: 'GBP',
    Chf: 'CHF',
    Nok: 'NOK',
    Dkk: 'DKK',
    Sek: 'SEK',
    Bgn: 'BGN',
    Hrk: 'HRK',
    Czk: 'CZK',
    Huf: 'HUF',
    Pln: 'PLN',
    Ron: 'RON',
    Isk: 'ISK',
    Rub: 'RUB',
    Mkd: 'MKD',
    Rsd: 'RSD',
    Ars: 'ARS',
    Bob: 'BOB',
    Brl: 'BRL',
    Clp: 'CLP',
    Cop: 'COP',
    Crc: 'CRC',
    Cup: 'CUP',
    Dop: 'DOP',
    Gtq: 'GTQ',
    Hnl: 'HNL',
    Mxn: 'MXN',
    Nio: 'NIO',
    Pab: 'PAB',
    Pyg: 'PYG',
    Pen: 'PEN',
    Srd: 'SRD',
    Uyu: 'UYU',
    Ves: 'VES',
    Usd: 'USD',
    Cad: 'CAD',
    Cny: 'CNY',
    Jpy: 'JPY',
    Inr: 'INR',
    Krw: 'KRW',
    Idr: 'IDR',
    Myr: 'MYR',
    Php: 'PHP',
    Sgd: 'SGD',
    Thb: 'THB',
    Vnd: 'VND',
    Hkd: 'HKD',
    Twd: 'TWD',
    Try: 'TRY',
    Aud: 'AUD',
    Nzd: 'NZD',
    Fjd: 'FJD',
    Pgk: 'PGK',
    Wst: 'WST',
    Vuv: 'VUV'
} as const;

export type Currencies = typeof Currencies[keyof typeof Currencies];


/**
 * 
 * @export
 * @interface FileItem
 */
export interface FileItem {
    /**
     * File name
     * @type {string}
     * @memberof FileItem
     */
    'name': string;
    /**
     * Uploaded file date
     * @type {string}
     * @memberof FileItem
     */
    'uploadedAt': string;
    /**
     * File size in bytes
     * @type {number}
     * @memberof FileItem
     */
    'size': number;
    /**
     * File mimetype
     * @type {string}
     * @memberof FileItem
     */
    'mimetype': string;
}
/**
 * 
 * @export
 * @interface MissingFieldDto
 */
export interface MissingFieldDto {
    /**
     * 
     * @type {string}
     * @memberof MissingFieldDto
     */
    'field': string;
    /**
     * 
     * @type {string}
     * @memberof MissingFieldDto
     */
    'type': string;
    /**
     * 
     * @type {boolean}
     * @memberof MissingFieldDto
     */
    'required': boolean;
}
/**
 * 
 * @export
 * @interface MissingFieldsDto
 */
export interface MissingFieldsDto {
    /**
     * Array of all the Case entity fields that are found missing for the evaluated case
     * @type {Array<MissingFieldDto>}
     * @memberof MissingFieldsDto
     */
    'missingFields': Array<MissingFieldDto>;
}
/**
 * 
 * @export
 * @interface UpdateCaseParams
 */
export interface UpdateCaseParams {
    /**
     * Filial identifier related to the case. This should be the NIF, VAT or other unique identifier that is configured for your organization in Kloutit. If you do not have filials in your organization, leave this field empty.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'filialIdentifier'?: string;
    /**
     * Date when the customer made the purchase in UTC and ISO 8601 format.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'purchaseDate'?: string;
    /**
     * Service that the customer bought.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'service'?: string;
    /**
     * Product that the customer bought.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'product'?: string;
    /**
     * Flag that indicates if the charge made is refundable regarding your company terms and conditions.
     * @type {boolean}
     * @memberof UpdateCaseParams
     */
    'isChargeRefundable'?: boolean;
    /**
     * Customer name.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'customerName'?: string;
    /**
     * Customer email
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'customerEmail'?: string;
    /**
     * Customer phone.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'customerPhone'?: string;
    /**
     * Date when the service was provided or will be provided in UTC and ISO 8601 format.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'serviceDate'?: string;
    /**
     * Flag that indicates if the service was provided or not.
     * @type {boolean}
     * @memberof UpdateCaseParams
     */
    'serviceWasProvided'?: boolean;
    /**
     * Check in date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'checkinDate'?: string;
    /**
     * Check out date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'checkoutDate'?: string;
    /**
     * Hotel name.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'hotelName'?: string;
    /**
     * Rate applied.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'rate'?: string;
    /**
     * Flag that indicates if the client made the checkin or not.
     * @type {boolean}
     * @memberof UpdateCaseParams
     */
    'checkinConfirmation'?: boolean;
    /**
     * Destination country.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'destinationCountry'?: string;
    /**
     * Departure date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'departureDate'?: string;
    /**
     * Arrival date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'arrivalDate'?: string;
    /**
     * Departure airport.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'departureAirport'?: string;
    /**
     * Arrival airport.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'arrivalAirport'?: string;
    /**
     * Departure city.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'departureCity'?: string;
    /**
     * Arrival city.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'arrivalCity'?: string;
    /**
     * Shipping city.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'shippingCity'?: string;
    /**
     * Shipping province.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'shippingProvince'?: string;
    /**
     * Shipping postal code.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'shippingPostalCode'?: string;
    /**
     * Shipping date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'shippingDate'?: string;
    /**
     * Delivery date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'deliveryDate'?: string;
    /**
     * Delivery company.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'deliveryCompany'?: string;
    /**
     * Flag that indicates if the customer received the product.
     * @type {boolean}
     * @memberof UpdateCaseParams
     */
    'deliveryConfirmation'?: boolean;
    /**
     * Start date in UTC and ISO 8601 format of the commitment that the customer has with the company.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'commitmentStartDate'?: string;
    /**
     * End date in UTC and ISO 8601 format of the commitment that the customer has with the company.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'commitmentEndDate'?: string;
    /**
     * Flag that indicates if the subscription is cancelled or active.
     * @type {boolean}
     * @memberof UpdateCaseParams
     */
    'isCancelled'?: boolean;
    /**
     * Product description.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'productDescription'?: string;
    /**
     * Date when the customer contacted to the merchant in UTC and ISO 8601 format.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'contactDate'?: string;
    /**
     * Array of all the emails that the customer has sent regarding this dispute. The structure of each item contains: **sender**: *customer* or *company*, **date**, **content**: string containing the message
     * @type {Array<CommunicationItem>}
     * @memberof UpdateCaseParams
     */
    'communications'?: Array<CommunicationItem>;
    /**
     * Additional info related to the chargeback.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'additionalInfo'?: string;
    /**
     * Last 4 digits of the customer\'s credit card number.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'last4Digits'?: string;
    /**
     * Transaction date in UTC and ISO 8601 format.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'transactionDate'?: string;
    /**
     * Purchase amount.
     * @type {Amount}
     * @memberof UpdateCaseParams
     */
    'purchaseAmount'?: Amount;
    /**
     * Customer bank name.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'bankName'?: string;
    /**
     * Card brand that the customer used to make the payment.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'cardBrand'?: string;
    /**
     * Flag that indicates if the purchase has been made with 3DS.
     * @type {boolean}
     * @memberof UpdateCaseParams
     */
    'is3DSPurchase'?: boolean;
    /**
     * 
     * @type {CaseSector}
     * @memberof UpdateCaseParams
     */
    'sector'?: CaseSector;
    /**
     * Date when the customer contacted to the seller in UTC and ISO 8601 format.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'sellerContactDate'?: string;
    /**
     * Seller additional infromation.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'sellerAdditionalInfo'?: string;
    /**
     * Seller name.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'sellerName'?: string;
    /**
     * Seller phone number.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'sellerPhone'?: string;
    /**
     * Seller email.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'sellerEmail'?: string;
    /**
     * Terms and Conditions URL. Only applies for sectors: TRAVEL_AIRLINE, TRAVEL_HOTEL and LEISURE.
     * @type {string}
     * @memberof UpdateCaseParams
     */
    'termsUrl'?: string;
}



/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthControllerHealth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthControllerHealth(options);
            const localVarOperationServerIndex = 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.healthControllerHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerHealth(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.healthControllerHealth(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @summary Health check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public healthControllerHealth(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthControllerHealth(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * KloutitCaseApi - axios parameter creator
 * @export
 */
export const KloutitCaseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Validates that the case has been updated with all the needed information. It indicates in the response if there are still some fields that could be informed to Kloutit before generating the dispute. It also informs the type and the required nature of each field.
         * @summary Check case information
         * @param {string} expedientNumber Case expedient number. This value must exist in Kloutit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkCase: async (expedientNumber: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'expedientNumber' is not null or undefined
            assertParamExists('checkCase', 'expedientNumber', expedientNumber)
            const localVarPath = `/case/{expedientNumber}/check-case`
                .replace(`{${"expedientNumber"}}`, encodeURIComponent(String(expedientNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits that the case has been updated with all the needed information. If you have configured automated dispute generation in Kloutit, this endpoint will indicate that the case is ready and will trigger the defense generation automatically.
         * @summary Submit completed case
         * @param {string} expedientNumber Case expedient number. This value must exist in Kloutit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitCompletedCase: async (expedientNumber: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'expedientNumber' is not null or undefined
            assertParamExists('submitCompletedCase', 'expedientNumber', expedientNumber)
            const localVarPath = `/case/{expedientNumber}/submit-completed-case`
                .replace(`{${"expedientNumber"}}`, encodeURIComponent(String(expedientNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates data to enrich an existing case in order to generate a more complete defense and increase the chances of winning.
         * @summary Update case
         * @param {string} expedientNumber Case expedient number. This value must exist in Kloutit.
         * @param {UpdateCaseParams} updateCaseParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCase: async (expedientNumber: string, updateCaseParams: UpdateCaseParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'expedientNumber' is not null or undefined
            assertParamExists('updateCase', 'expedientNumber', expedientNumber)
            // verify required parameter 'updateCaseParams' is not null or undefined
            assertParamExists('updateCase', 'updateCaseParams', updateCaseParams)
            const localVarPath = `/case/{expedientNumber}/update-case`
                .replace(`{${"expedientNumber"}}`, encodeURIComponent(String(expedientNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCaseParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads a file into an existing case. You need to send a request of type ``multipart/form-data``. This file can be attached as a customer evidence, company evidence or product related file (for marketplace). Allowed formats are ``PDF``, ``JPG``, ``JPEG``, ``PNG``. Max. file size is ``10Mb``
         * @summary Upload file
         * @param {string} expedientNumber 
         * @param {File} file A file to upload. Make sure that the specifications follow RFC 2388, which defines file transfers for the multipart/form-data protocol. Allowed formats are &#x60;&#x60;PDF&#x60;&#x60;, &#x60;&#x60;JPG&#x60;&#x60;, &#x60;&#x60;JPEG&#x60;&#x60;, &#x60;&#x60;PNG&#x60;&#x60;. Max. file size is &#x60;&#x60;10Mb&#x60;&#x60;. Ensure that the file upload adheres to [RFC 2388](https://www.ietf.org/rfc/rfc2388.txt), which defines file transfers for the multipart/form-data protocol.
         * @param {UploadFileTypeEnum} type Type of file: &#x60;&#x60;customer&#x60;&#x60;, &#x60;&#x60;company&#x60;&#x60; or &#x60;&#x60;product&#x60;&#x60; (product only for marketplace)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (expedientNumber: string, file: File, type: UploadFileTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'expedientNumber' is not null or undefined
            assertParamExists('uploadFile', 'expedientNumber', expedientNumber)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadFile', 'file', file)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('uploadFile', 'type', type)
            const localVarPath = `/case/{expedientNumber}/upload-file`
                .replace(`{${"expedientNumber"}}`, encodeURIComponent(String(expedientNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.append('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KloutitCaseApi - functional programming interface
 * @export
 */
export const KloutitCaseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KloutitCaseApiAxiosParamCreator(configuration)
    return {
        /**
         * Validates that the case has been updated with all the needed information. It indicates in the response if there are still some fields that could be informed to Kloutit before generating the dispute. It also informs the type and the required nature of each field.
         * @summary Check case information
         * @param {string} expedientNumber Case expedient number. This value must exist in Kloutit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkCase(expedientNumber: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkCase(expedientNumber, options);
            const localVarOperationServerIndex = 0;
            const localVarOperationServerBasePath = operationServerMap['KloutitCaseApi.checkCase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submits that the case has been updated with all the needed information. If you have configured automated dispute generation in Kloutit, this endpoint will indicate that the case is ready and will trigger the defense generation automatically.
         * @summary Submit completed case
         * @param {string} expedientNumber Case expedient number. This value must exist in Kloutit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitCompletedCase(expedientNumber: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitCompletedCase(expedientNumber, options);
            const localVarOperationServerIndex = 0;
            const localVarOperationServerBasePath = operationServerMap['KloutitCaseApi.submitCompletedCase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates data to enrich an existing case in order to generate a more complete defense and increase the chances of winning.
         * @summary Update case
         * @param {string} expedientNumber Case expedient number. This value must exist in Kloutit.
         * @param {UpdateCaseParams} updateCaseParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCase(expedientNumber: string, updateCaseParams: UpdateCaseParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Case>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCase(expedientNumber, updateCaseParams, options);
            const localVarOperationServerIndex = 0;
            const localVarOperationServerBasePath = operationServerMap['KloutitCaseApi.updateCase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uploads a file into an existing case. You need to send a request of type ``multipart/form-data``. This file can be attached as a customer evidence, company evidence or product related file (for marketplace). Allowed formats are ``PDF``, ``JPG``, ``JPEG``, ``PNG``. Max. file size is ``10Mb``
         * @summary Upload file
         * @param {string} expedientNumber 
         * @param {File} file A file to upload. Make sure that the specifications follow RFC 2388, which defines file transfers for the multipart/form-data protocol. Allowed formats are &#x60;&#x60;PDF&#x60;&#x60;, &#x60;&#x60;JPG&#x60;&#x60;, &#x60;&#x60;JPEG&#x60;&#x60;, &#x60;&#x60;PNG&#x60;&#x60;. Max. file size is &#x60;&#x60;10Mb&#x60;&#x60;. Ensure that the file upload adheres to [RFC 2388](https://www.ietf.org/rfc/rfc2388.txt), which defines file transfers for the multipart/form-data protocol.
         * @param {UploadFileTypeEnum} type Type of file: &#x60;&#x60;customer&#x60;&#x60;, &#x60;&#x60;company&#x60;&#x60; or &#x60;&#x60;product&#x60;&#x60; (product only for marketplace)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(expedientNumber: string, file: File, type: UploadFileTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(expedientNumber, file, type, options);
            const localVarOperationServerIndex = 0;
            const localVarOperationServerBasePath = operationServerMap['KloutitCaseApi.uploadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * KloutitCaseApi - factory interface
 * @export
 */
export const KloutitCaseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KloutitCaseApiFp(configuration)
    return {
        /**
         * Validates that the case has been updated with all the needed information. It indicates in the response if there are still some fields that could be informed to Kloutit before generating the dispute. It also informs the type and the required nature of each field.
         * @summary Check case information
         * @param {string} expedientNumber Case expedient number. This value must exist in Kloutit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkCase(expedientNumber: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.checkCase(expedientNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Submits that the case has been updated with all the needed information. If you have configured automated dispute generation in Kloutit, this endpoint will indicate that the case is ready and will trigger the defense generation automatically.
         * @summary Submit completed case
         * @param {string} expedientNumber Case expedient number. This value must exist in Kloutit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitCompletedCase(expedientNumber: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.submitCompletedCase(expedientNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates data to enrich an existing case in order to generate a more complete defense and increase the chances of winning.
         * @summary Update case
         * @param {string} expedientNumber Case expedient number. This value must exist in Kloutit.
         * @param {UpdateCaseParams} updateCaseParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCase(expedientNumber: string, updateCaseParams: UpdateCaseParams, options?: RawAxiosRequestConfig): AxiosPromise<Case> {
            return localVarFp.updateCase(expedientNumber, updateCaseParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads a file into an existing case. You need to send a request of type ``multipart/form-data``. This file can be attached as a customer evidence, company evidence or product related file (for marketplace). Allowed formats are ``PDF``, ``JPG``, ``JPEG``, ``PNG``. Max. file size is ``10Mb``
         * @summary Upload file
         * @param {string} expedientNumber 
         * @param {File} file A file to upload. Make sure that the specifications follow RFC 2388, which defines file transfers for the multipart/form-data protocol. Allowed formats are &#x60;&#x60;PDF&#x60;&#x60;, &#x60;&#x60;JPG&#x60;&#x60;, &#x60;&#x60;JPEG&#x60;&#x60;, &#x60;&#x60;PNG&#x60;&#x60;. Max. file size is &#x60;&#x60;10Mb&#x60;&#x60;. Ensure that the file upload adheres to [RFC 2388](https://www.ietf.org/rfc/rfc2388.txt), which defines file transfers for the multipart/form-data protocol.
         * @param {UploadFileTypeEnum} type Type of file: &#x60;&#x60;customer&#x60;&#x60;, &#x60;&#x60;company&#x60;&#x60; or &#x60;&#x60;product&#x60;&#x60; (product only for marketplace)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(expedientNumber: string, file: File, type: UploadFileTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<FileItem> {
            return localVarFp.uploadFile(expedientNumber, file, type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KloutitCaseApi - object-oriented interface
 * @export
 * @class KloutitCaseApi
 * @extends {BaseAPI}
 */
export class KloutitCaseApi extends BaseAPI {
    /**
     * Validates that the case has been updated with all the needed information. It indicates in the response if there are still some fields that could be informed to Kloutit before generating the dispute. It also informs the type and the required nature of each field.
     * @summary Check case information
     * @param {string} expedientNumber Case expedient number. This value must exist in Kloutit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KloutitCaseApi
     */
    public checkCase(expedientNumber: string, options?: RawAxiosRequestConfig) {
        return KloutitCaseApiFp(this.configuration).checkCase(expedientNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submits that the case has been updated with all the needed information. If you have configured automated dispute generation in Kloutit, this endpoint will indicate that the case is ready and will trigger the defense generation automatically.
     * @summary Submit completed case
     * @param {string} expedientNumber Case expedient number. This value must exist in Kloutit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KloutitCaseApi
     */
    public submitCompletedCase(expedientNumber: string, options?: RawAxiosRequestConfig) {
        return KloutitCaseApiFp(this.configuration).submitCompletedCase(expedientNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates data to enrich an existing case in order to generate a more complete defense and increase the chances of winning.
     * @summary Update case
     * @param {string} expedientNumber Case expedient number. This value must exist in Kloutit.
     * @param {UpdateCaseParams} updateCaseParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KloutitCaseApi
     */
    public updateCase(expedientNumber: string, updateCaseParams: UpdateCaseParams, options?: RawAxiosRequestConfig) {
        return KloutitCaseApiFp(this.configuration).updateCase(expedientNumber, updateCaseParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads a file into an existing case. You need to send a request of type ``multipart/form-data``. This file can be attached as a customer evidence, company evidence or product related file (for marketplace). Allowed formats are ``PDF``, ``JPG``, ``JPEG``, ``PNG``. Max. file size is ``10Mb``
     * @summary Upload file
     * @param {string} expedientNumber 
     * @param {File} file A file to upload. Make sure that the specifications follow RFC 2388, which defines file transfers for the multipart/form-data protocol. Allowed formats are &#x60;&#x60;PDF&#x60;&#x60;, &#x60;&#x60;JPG&#x60;&#x60;, &#x60;&#x60;JPEG&#x60;&#x60;, &#x60;&#x60;PNG&#x60;&#x60;. Max. file size is &#x60;&#x60;10Mb&#x60;&#x60;. Ensure that the file upload adheres to [RFC 2388](https://www.ietf.org/rfc/rfc2388.txt), which defines file transfers for the multipart/form-data protocol.
     * @param {UploadFileTypeEnum} type Type of file: &#x60;&#x60;customer&#x60;&#x60;, &#x60;&#x60;company&#x60;&#x60; or &#x60;&#x60;product&#x60;&#x60; (product only for marketplace)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KloutitCaseApi
     */
    public uploadFile(expedientNumber: string, file: File, type: UploadFileTypeEnum, options?: RawAxiosRequestConfig) {
        return KloutitCaseApiFp(this.configuration).uploadFile(expedientNumber, file, type, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const UploadFileTypeEnum = {
    Company: 'COMPANY',
    Customer: 'CUSTOMER',
    Product: 'PRODUCT'
} as const;
export type UploadFileTypeEnum = typeof UploadFileTypeEnum[keyof typeof UploadFileTypeEnum];


